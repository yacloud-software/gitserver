// Code generated by protoc-gen-go.
// source: golang.conradwood.net/apis/gitserver/gitserver.proto
// DO NOT EDIT!

/*
Package gitserver is a generated protocol buffer package.

It is generated from these files:
	golang.conradwood.net/apis/gitserver/gitserver.proto

It has these top-level messages:
	GitCredentials
	InternalGitHost
	CreateGitCredentialsRequest
	RepoTagRequest
	CreateRepoLog
	GitAccessLog
	Build
	BuildList
	RepositoryList
	Permission
	Watchers
	Repository
	GroupRepositoryAccess
	UserRepositoryAccess
	PostReceiveRequest
	PostReceiveStream
	ByIDRequest
	RebuildRequest
	ByURLRequest
	RepositoryInfo
	GitInfo
	CreateRepoRequest
	SourceRepository
	SourceRepositoryURL
	SourceRepositoryList
	SetRepoFlagsRequest
	ForkRequest
	PingResponse
	PingState
	CheckGitRequest
	CheckGitResponse
	RepoFilter
	UpdateRepoStatusRequest
	HookRequest
	HookResponse
	RepoUpdateRequest
	SourceRepositoryResponse
	DenyMessageRequest
	NumberCommitsUserRequest
	NumberCommitsUserResponse
	GetNTagRequest
	AttachNTagRequest
	NRepoTagID
	NTagResponse
	GitCredentialsRequest
	GitCredentialsResponse
*/
package gitserver

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import common "golang.conradwood.net/apis/common"
import auth "golang.conradwood.net/apis/auth"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

//
// SC_FIRMWARE_XXX means the main singingcat 'kernel' running on cpu XXX
// note that a repo can have multiple tags, for example an SC_APP_XXX can be compiled from the same source in a repo
// TODO: merge this with golang.singingcat.net/apis/firmwaretracker. Probably involves changing it from 'tag' to 'resulting_in' based system
type REPOTAG int32

const (
	REPOTAG_UNDEFINED              REPOTAG = 0
	REPOTAG_SC_FIRMWARE_STM32L15X  REPOTAG = 1
	REPOTAG_SC_LOADER_STM32L15X    REPOTAG = 2
	REPOTAG_SC_APP_STM32L15X       REPOTAG = 3
	REPOTAG_ESP8266_AS_COPROCESSOR REPOTAG = 4
	REPOTAG_ESP32_AS_COPROCESSOR   REPOTAG = 5
	REPOTAG_SC_FIRMWARE_ESP32      REPOTAG = 6
	REPOTAG_SC_APP_ESP32           REPOTAG = 7
)

var REPOTAG_name = map[int32]string{
	0: "UNDEFINED",
	1: "SC_FIRMWARE_STM32L15X",
	2: "SC_LOADER_STM32L15X",
	3: "SC_APP_STM32L15X",
	4: "ESP8266_AS_COPROCESSOR",
	5: "ESP32_AS_COPROCESSOR",
	6: "SC_FIRMWARE_ESP32",
	7: "SC_APP_ESP32",
}
var REPOTAG_value = map[string]int32{
	"UNDEFINED":              0,
	"SC_FIRMWARE_STM32L15X":  1,
	"SC_LOADER_STM32L15X":    2,
	"SC_APP_STM32L15X":       3,
	"ESP8266_AS_COPROCESSOR": 4,
	"ESP32_AS_COPROCESSOR":   5,
	"SC_FIRMWARE_ESP32":      6,
	"SC_APP_ESP32":           7,
}

func (x REPOTAG) String() string {
	return proto.EnumName(REPOTAG_name, int32(x))
}
func (REPOTAG) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type NewRepoState int32

const (
	NewRepoState_NOCHANGE  NewRepoState = 0
	NewRepoState_SET_TRUE  NewRepoState = 1
	NewRepoState_SET_FALSE NewRepoState = 2
)

var NewRepoState_name = map[int32]string{
	0: "NOCHANGE",
	1: "SET_TRUE",
	2: "SET_FALSE",
}
var NewRepoState_value = map[string]int32{
	"NOCHANGE":  0,
	"SET_TRUE":  1,
	"SET_FALSE": 2,
}

func (x NewRepoState) String() string {
	return proto.EnumName(NewRepoState_name, int32(x))
}
func (NewRepoState) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

type GitCredentials struct {
	ID       uint64 `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	UserID   string `protobuf:"bytes,2,opt,name=UserID" json:"UserID,omitempty"`
	Host     string `protobuf:"bytes,3,opt,name=Host" json:"Host,omitempty"`
	Path     string `protobuf:"bytes,4,opt,name=Path" json:"Path,omitempty"`
	Username string `protobuf:"bytes,5,opt,name=Username" json:"Username,omitempty"`
	Password string `protobuf:"bytes,6,opt,name=Password" json:"Password,omitempty"`
	Expiry   uint32 `protobuf:"varint,7,opt,name=Expiry" json:"Expiry,omitempty"`
}

func (m *GitCredentials) Reset()                    { *m = GitCredentials{} }
func (m *GitCredentials) String() string            { return proto.CompactTextString(m) }
func (*GitCredentials) ProtoMessage()               {}
func (*GitCredentials) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *GitCredentials) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *GitCredentials) GetUserID() string {
	if m != nil {
		return m.UserID
	}
	return ""
}

func (m *GitCredentials) GetHost() string {
	if m != nil {
		return m.Host
	}
	return ""
}

func (m *GitCredentials) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *GitCredentials) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *GitCredentials) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

func (m *GitCredentials) GetExpiry() uint32 {
	if m != nil {
		return m.Expiry
	}
	return 0
}

type InternalGitHost struct {
	ID     uint64 `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	Host   string `protobuf:"bytes,2,opt,name=Host" json:"Host,omitempty"`
	Expiry uint32 `protobuf:"varint,3,opt,name=Expiry" json:"Expiry,omitempty"`
}

func (m *InternalGitHost) Reset()                    { *m = InternalGitHost{} }
func (m *InternalGitHost) String() string            { return proto.CompactTextString(m) }
func (*InternalGitHost) ProtoMessage()               {}
func (*InternalGitHost) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *InternalGitHost) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *InternalGitHost) GetHost() string {
	if m != nil {
		return m.Host
	}
	return ""
}

func (m *InternalGitHost) GetExpiry() uint32 {
	if m != nil {
		return m.Expiry
	}
	return 0
}

type CreateGitCredentialsRequest struct {
	Credentials         *GitCredentials `protobuf:"bytes,1,opt,name=Credentials" json:"Credentials,omitempty"`
	TreatHostAsInternal bool            `protobuf:"varint,2,opt,name=TreatHostAsInternal" json:"TreatHostAsInternal,omitempty"`
}

func (m *CreateGitCredentialsRequest) Reset()                    { *m = CreateGitCredentialsRequest{} }
func (m *CreateGitCredentialsRequest) String() string            { return proto.CompactTextString(m) }
func (*CreateGitCredentialsRequest) ProtoMessage()               {}
func (*CreateGitCredentialsRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *CreateGitCredentialsRequest) GetCredentials() *GitCredentials {
	if m != nil {
		return m.Credentials
	}
	return nil
}

func (m *CreateGitCredentialsRequest) GetTreatHostAsInternal() bool {
	if m != nil {
		return m.TreatHostAsInternal
	}
	return false
}

type RepoTagRequest struct {
	Tag uint32 `protobuf:"varint,1,opt,name=Tag" json:"Tag,omitempty"`
}

func (m *RepoTagRequest) Reset()                    { *m = RepoTagRequest{} }
func (m *RepoTagRequest) String() string            { return proto.CompactTextString(m) }
func (*RepoTagRequest) ProtoMessage()               {}
func (*RepoTagRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *RepoTagRequest) GetTag() uint32 {
	if m != nil {
		return m.Tag
	}
	return 0
}

// a log and statemachine in the database for creating repos
type CreateRepoLog struct {
	// database id
	ID uint64 `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	// which repo does it refer to?
	RepositoryID uint64 `protobuf:"varint,2,opt,name=RepositoryID" json:"RepositoryID,omitempty"`
	// user who runs this (also in context)
	UserID string `protobuf:"bytes,3,opt,name=UserID" json:"UserID,omitempty"`
	// serialised context
	Context string `protobuf:"bytes,4,opt,name=Context" json:"Context,omitempty"`
	// defines what this 'logentry' does/did. See gitserver source for specifics
	Action uint32 `protobuf:"varint,5,opt,name=Action" json:"Action,omitempty"`
	// true if this succeeded
	Success bool `protobuf:"varint,6,opt,name=Success" json:"Success,omitempty"`
	// if !success, here's the error message
	ErrorMessage     string `protobuf:"bytes,7,opt,name=ErrorMessage" json:"ErrorMessage,omitempty"`
	Started          uint32 `protobuf:"varint,8,opt,name=Started" json:"Started,omitempty"`
	Finished         uint32 `protobuf:"varint,9,opt,name=Finished" json:"Finished,omitempty"`
	AssociationToken string `protobuf:"bytes,10,opt,name=AssociationToken" json:"AssociationToken,omitempty"`
}

func (m *CreateRepoLog) Reset()                    { *m = CreateRepoLog{} }
func (m *CreateRepoLog) String() string            { return proto.CompactTextString(m) }
func (*CreateRepoLog) ProtoMessage()               {}
func (*CreateRepoLog) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *CreateRepoLog) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *CreateRepoLog) GetRepositoryID() uint64 {
	if m != nil {
		return m.RepositoryID
	}
	return 0
}

func (m *CreateRepoLog) GetUserID() string {
	if m != nil {
		return m.UserID
	}
	return ""
}

func (m *CreateRepoLog) GetContext() string {
	if m != nil {
		return m.Context
	}
	return ""
}

func (m *CreateRepoLog) GetAction() uint32 {
	if m != nil {
		return m.Action
	}
	return 0
}

func (m *CreateRepoLog) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

func (m *CreateRepoLog) GetErrorMessage() string {
	if m != nil {
		return m.ErrorMessage
	}
	return ""
}

func (m *CreateRepoLog) GetStarted() uint32 {
	if m != nil {
		return m.Started
	}
	return 0
}

func (m *CreateRepoLog) GetFinished() uint32 {
	if m != nil {
		return m.Finished
	}
	return 0
}

func (m *CreateRepoLog) GetAssociationToken() string {
	if m != nil {
		return m.AssociationToken
	}
	return ""
}

type GitAccessLog struct {
	ID               uint64            `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	Write            bool              `protobuf:"varint,2,opt,name=Write" json:"Write,omitempty"`
	UserID           string            `protobuf:"bytes,4,opt,name=UserID" json:"UserID,omitempty"`
	Timestamp        uint32            `protobuf:"varint,6,opt,name=Timestamp" json:"Timestamp,omitempty"`
	SourceRepository *SourceRepository `protobuf:"bytes,7,opt,name=SourceRepository" json:"SourceRepository,omitempty"`
}

func (m *GitAccessLog) Reset()                    { *m = GitAccessLog{} }
func (m *GitAccessLog) String() string            { return proto.CompactTextString(m) }
func (*GitAccessLog) ProtoMessage()               {}
func (*GitAccessLog) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *GitAccessLog) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *GitAccessLog) GetWrite() bool {
	if m != nil {
		return m.Write
	}
	return false
}

func (m *GitAccessLog) GetUserID() string {
	if m != nil {
		return m.UserID
	}
	return ""
}

func (m *GitAccessLog) GetTimestamp() uint32 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *GitAccessLog) GetSourceRepository() *SourceRepository {
	if m != nil {
		return m.SourceRepository
	}
	return nil
}

type Build struct {
	ID           uint64 `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	RepositoryID uint64 `protobuf:"varint,2,opt,name=RepositoryID" json:"RepositoryID,omitempty"`
	CommitHash   string `protobuf:"bytes,3,opt,name=CommitHash" json:"CommitHash,omitempty"`
	Branch       string `protobuf:"bytes,4,opt,name=Branch" json:"Branch,omitempty"`
	LogMessage   string `protobuf:"bytes,5,opt,name=LogMessage" json:"LogMessage,omitempty"`
	UserID       string `protobuf:"bytes,6,opt,name=UserID" json:"UserID,omitempty"`
	Timestamp    uint32 `protobuf:"varint,7,opt,name=Timestamp" json:"Timestamp,omitempty"`
	Success      bool   `protobuf:"varint,8,opt,name=Success" json:"Success,omitempty"`
}

func (m *Build) Reset()                    { *m = Build{} }
func (m *Build) String() string            { return proto.CompactTextString(m) }
func (*Build) ProtoMessage()               {}
func (*Build) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *Build) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Build) GetRepositoryID() uint64 {
	if m != nil {
		return m.RepositoryID
	}
	return 0
}

func (m *Build) GetCommitHash() string {
	if m != nil {
		return m.CommitHash
	}
	return ""
}

func (m *Build) GetBranch() string {
	if m != nil {
		return m.Branch
	}
	return ""
}

func (m *Build) GetLogMessage() string {
	if m != nil {
		return m.LogMessage
	}
	return ""
}

func (m *Build) GetUserID() string {
	if m != nil {
		return m.UserID
	}
	return ""
}

func (m *Build) GetTimestamp() uint32 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *Build) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

type BuildList struct {
	Builds []*Build `protobuf:"bytes,1,rep,name=Builds" json:"Builds,omitempty"`
}

func (m *BuildList) Reset()                    { *m = BuildList{} }
func (m *BuildList) String() string            { return proto.CompactTextString(m) }
func (*BuildList) ProtoMessage()               {}
func (*BuildList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *BuildList) GetBuilds() []*Build {
	if m != nil {
		return m.Builds
	}
	return nil
}

type RepositoryList struct {
	Repos []*Repository `protobuf:"bytes,1,rep,name=Repos" json:"Repos,omitempty"`
}

func (m *RepositoryList) Reset()                    { *m = RepositoryList{} }
func (m *RepositoryList) String() string            { return proto.CompactTextString(m) }
func (*RepositoryList) ProtoMessage()               {}
func (*RepositoryList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *RepositoryList) GetRepos() []*Repository {
	if m != nil {
		return m.Repos
	}
	return nil
}

type Permission struct {
	Read    bool `protobuf:"varint,1,opt,name=Read" json:"Read,omitempty"`
	Write   bool `protobuf:"varint,2,opt,name=Write" json:"Write,omitempty"`
	Execute bool `protobuf:"varint,3,opt,name=Execute" json:"Execute,omitempty"`
	List    bool `protobuf:"varint,4,opt,name=List" json:"List,omitempty"`
}

func (m *Permission) Reset()                    { *m = Permission{} }
func (m *Permission) String() string            { return proto.CompactTextString(m) }
func (*Permission) ProtoMessage()               {}
func (*Permission) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *Permission) GetRead() bool {
	if m != nil {
		return m.Read
	}
	return false
}

func (m *Permission) GetWrite() bool {
	if m != nil {
		return m.Write
	}
	return false
}

func (m *Permission) GetExecute() bool {
	if m != nil {
		return m.Execute
	}
	return false
}

func (m *Permission) GetList() bool {
	if m != nil {
		return m.List
	}
	return false
}

//
// A "watcher" is someone who watches pushes to a given repository.
// Note that pushes by "oneself" will not be notified.
// Otherwise each push will be send via slack
type Watchers struct {
	ID           uint64 `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	UserID       string `protobuf:"bytes,2,opt,name=UserID" json:"UserID,omitempty"`
	RepositoryID uint64 `protobuf:"varint,3,opt,name=RepositoryID" json:"RepositoryID,omitempty"`
	Notifytype   uint32 `protobuf:"varint,4,opt,name=Notifytype" json:"Notifytype,omitempty"`
}

func (m *Watchers) Reset()                    { *m = Watchers{} }
func (m *Watchers) String() string            { return proto.CompactTextString(m) }
func (*Watchers) ProtoMessage()               {}
func (*Watchers) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *Watchers) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Watchers) GetUserID() string {
	if m != nil {
		return m.UserID
	}
	return ""
}

func (m *Watchers) GetRepositoryID() uint64 {
	if m != nil {
		return m.RepositoryID
	}
	return 0
}

func (m *Watchers) GetNotifytype() uint32 {
	if m != nil {
		return m.Notifytype
	}
	return 0
}

type Repository struct {
	ID           uint64      `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	RepoName     string      `protobuf:"bytes,2,opt,name=RepoName" json:"RepoName,omitempty"`
	OwnerID      string      `protobuf:"bytes,3,opt,name=OwnerID" json:"OwnerID,omitempty"`
	ArtefactName string      `protobuf:"bytes,4,opt,name=ArtefactName" json:"ArtefactName,omitempty"`
	Permission   *Permission `protobuf:"bytes,5,opt,name=Permission" json:"Permission,omitempty"`
}

func (m *Repository) Reset()                    { *m = Repository{} }
func (m *Repository) String() string            { return proto.CompactTextString(m) }
func (*Repository) ProtoMessage()               {}
func (*Repository) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *Repository) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Repository) GetRepoName() string {
	if m != nil {
		return m.RepoName
	}
	return ""
}

func (m *Repository) GetOwnerID() string {
	if m != nil {
		return m.OwnerID
	}
	return ""
}

func (m *Repository) GetArtefactName() string {
	if m != nil {
		return m.ArtefactName
	}
	return ""
}

func (m *Repository) GetPermission() *Permission {
	if m != nil {
		return m.Permission
	}
	return nil
}

type GroupRepositoryAccess struct {
	ID      uint64 `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	RepoID  uint64 `protobuf:"varint,2,opt,name=RepoID" json:"RepoID,omitempty"`
	GroupID string `protobuf:"bytes,3,opt,name=GroupID" json:"GroupID,omitempty"`
	Read    bool   `protobuf:"varint,4,opt,name=Read" json:"Read,omitempty"`
	Write   bool   `protobuf:"varint,5,opt,name=Write" json:"Write,omitempty"`
}

func (m *GroupRepositoryAccess) Reset()                    { *m = GroupRepositoryAccess{} }
func (m *GroupRepositoryAccess) String() string            { return proto.CompactTextString(m) }
func (*GroupRepositoryAccess) ProtoMessage()               {}
func (*GroupRepositoryAccess) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *GroupRepositoryAccess) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *GroupRepositoryAccess) GetRepoID() uint64 {
	if m != nil {
		return m.RepoID
	}
	return 0
}

func (m *GroupRepositoryAccess) GetGroupID() string {
	if m != nil {
		return m.GroupID
	}
	return ""
}

func (m *GroupRepositoryAccess) GetRead() bool {
	if m != nil {
		return m.Read
	}
	return false
}

func (m *GroupRepositoryAccess) GetWrite() bool {
	if m != nil {
		return m.Write
	}
	return false
}

type UserRepositoryAccess struct {
	ID     uint64 `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	RepoID uint64 `protobuf:"varint,2,opt,name=RepoID" json:"RepoID,omitempty"`
	UserID string `protobuf:"bytes,3,opt,name=UserID" json:"UserID,omitempty"`
	Read   bool   `protobuf:"varint,4,opt,name=Read" json:"Read,omitempty"`
	Write  bool   `protobuf:"varint,5,opt,name=Write" json:"Write,omitempty"`
}

func (m *UserRepositoryAccess) Reset()                    { *m = UserRepositoryAccess{} }
func (m *UserRepositoryAccess) String() string            { return proto.CompactTextString(m) }
func (*UserRepositoryAccess) ProtoMessage()               {}
func (*UserRepositoryAccess) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *UserRepositoryAccess) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *UserRepositoryAccess) GetRepoID() uint64 {
	if m != nil {
		return m.RepoID
	}
	return 0
}

func (m *UserRepositoryAccess) GetUserID() string {
	if m != nil {
		return m.UserID
	}
	return ""
}

func (m *UserRepositoryAccess) GetRead() bool {
	if m != nil {
		return m.Read
	}
	return false
}

func (m *UserRepositoryAccess) GetWrite() bool {
	if m != nil {
		return m.Write
	}
	return false
}

type PostReceiveRequest struct {
	RepoDirectory string `protobuf:"bytes,1,opt,name=RepoDirectory" json:"RepoDirectory,omitempty"`
	Ref           string `protobuf:"bytes,2,opt,name=Ref" json:"Ref,omitempty"`
	OldRevision   string `protobuf:"bytes,3,opt,name=OldRevision" json:"OldRevision,omitempty"`
	NewRevision   string `protobuf:"bytes,4,opt,name=NewRevision" json:"NewRevision,omitempty"`
}

func (m *PostReceiveRequest) Reset()                    { *m = PostReceiveRequest{} }
func (m *PostReceiveRequest) String() string            { return proto.CompactTextString(m) }
func (*PostReceiveRequest) ProtoMessage()               {}
func (*PostReceiveRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *PostReceiveRequest) GetRepoDirectory() string {
	if m != nil {
		return m.RepoDirectory
	}
	return ""
}

func (m *PostReceiveRequest) GetRef() string {
	if m != nil {
		return m.Ref
	}
	return ""
}

func (m *PostReceiveRequest) GetOldRevision() string {
	if m != nil {
		return m.OldRevision
	}
	return ""
}

func (m *PostReceiveRequest) GetNewRevision() string {
	if m != nil {
		return m.NewRevision
	}
	return ""
}

type PostReceiveStream struct {
}

func (m *PostReceiveStream) Reset()                    { *m = PostReceiveStream{} }
func (m *PostReceiveStream) String() string            { return proto.CompactTextString(m) }
func (*PostReceiveStream) ProtoMessage()               {}
func (*PostReceiveStream) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

type ByIDRequest struct {
	ID uint64 `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
}

func (m *ByIDRequest) Reset()                    { *m = ByIDRequest{} }
func (m *ByIDRequest) String() string            { return proto.CompactTextString(m) }
func (*ByIDRequest) ProtoMessage()               {}
func (*ByIDRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *ByIDRequest) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

type RebuildRequest struct {
	ID                  uint64   `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	ExcludeBuildScripts []string `protobuf:"bytes,2,rep,name=ExcludeBuildScripts" json:"ExcludeBuildScripts,omitempty"`
}

func (m *RebuildRequest) Reset()                    { *m = RebuildRequest{} }
func (m *RebuildRequest) String() string            { return proto.CompactTextString(m) }
func (*RebuildRequest) ProtoMessage()               {}
func (*RebuildRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

func (m *RebuildRequest) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *RebuildRequest) GetExcludeBuildScripts() []string {
	if m != nil {
		return m.ExcludeBuildScripts
	}
	return nil
}

type ByURLRequest struct {
	URL string `protobuf:"bytes,1,opt,name=URL" json:"URL,omitempty"`
}

func (m *ByURLRequest) Reset()                    { *m = ByURLRequest{} }
func (m *ByURLRequest) String() string            { return proto.CompactTextString(m) }
func (*ByURLRequest) ProtoMessage()               {}
func (*ByURLRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

func (m *ByURLRequest) GetURL() string {
	if m != nil {
		return m.URL
	}
	return ""
}

type RepositoryInfo struct {
	Repository *Repository `protobuf:"bytes,1,opt,name=Repository" json:"Repository,omitempty"`
}

func (m *RepositoryInfo) Reset()                    { *m = RepositoryInfo{} }
func (m *RepositoryInfo) String() string            { return proto.CompactTextString(m) }
func (*RepositoryInfo) ProtoMessage()               {}
func (*RepositoryInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{19} }

func (m *RepositoryInfo) GetRepository() *Repository {
	if m != nil {
		return m.Repository
	}
	return nil
}

// this message is passed through the CGI as environment variable back to the builder
type GitInfo struct {
	RepositoryID uint64     `protobuf:"varint,1,opt,name=RepositoryID" json:"RepositoryID,omitempty"`
	UserID       string     `protobuf:"bytes,2,opt,name=UserID" json:"UserID,omitempty"`
	User         *auth.User `protobuf:"bytes,3,opt,name=User" json:"User,omitempty"`
	Version      uint32     `protobuf:"varint,4,opt,name=Version" json:"Version,omitempty"`
	URL          string     `protobuf:"bytes,5,opt,name=URL" json:"URL,omitempty"`
}

func (m *GitInfo) Reset()                    { *m = GitInfo{} }
func (m *GitInfo) String() string            { return proto.CompactTextString(m) }
func (*GitInfo) ProtoMessage()               {}
func (*GitInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{20} }

func (m *GitInfo) GetRepositoryID() uint64 {
	if m != nil {
		return m.RepositoryID
	}
	return 0
}

func (m *GitInfo) GetUserID() string {
	if m != nil {
		return m.UserID
	}
	return ""
}

func (m *GitInfo) GetUser() *auth.User {
	if m != nil {
		return m.User
	}
	return nil
}

func (m *GitInfo) GetVersion() uint32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *GitInfo) GetURL() string {
	if m != nil {
		return m.URL
	}
	return ""
}

type CreateRepoRequest struct {
	ArtefactName      string               `protobuf:"bytes,1,opt,name=ArtefactName" json:"ArtefactName,omitempty"`
	URL               *SourceRepositoryURL `protobuf:"bytes,2,opt,name=URL" json:"URL,omitempty"`
	Description       string               `protobuf:"bytes,3,opt,name=Description" json:"Description,omitempty"`
	CompleteForAccess bool                 `protobuf:"varint,4,opt,name=CompleteForAccess" json:"CompleteForAccess,omitempty"`
}

func (m *CreateRepoRequest) Reset()                    { *m = CreateRepoRequest{} }
func (m *CreateRepoRequest) String() string            { return proto.CompactTextString(m) }
func (*CreateRepoRequest) ProtoMessage()               {}
func (*CreateRepoRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{21} }

func (m *CreateRepoRequest) GetArtefactName() string {
	if m != nil {
		return m.ArtefactName
	}
	return ""
}

func (m *CreateRepoRequest) GetURL() *SourceRepositoryURL {
	if m != nil {
		return m.URL
	}
	return nil
}

func (m *CreateRepoRequest) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *CreateRepoRequest) GetCompleteForAccess() bool {
	if m != nil {
		return m.CompleteForAccess
	}
	return false
}

// stored in database. Maps a URL to a filepath and a unique ID
type SourceRepository struct {
	ID           uint64                 `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	FilePath     string                 `protobuf:"bytes,2,opt,name=FilePath" json:"FilePath,omitempty"`
	URLs         []*SourceRepositoryURL `protobuf:"bytes,3,rep,name=URLs" json:"URLs,omitempty"`
	ArtefactName string                 `protobuf:"bytes,4,opt,name=ArtefactName" json:"ArtefactName,omitempty"`
	// if true: run the post-receive hook
	RunPostReceive bool `protobuf:"varint,5,opt,name=RunPostReceive" json:"RunPostReceive,omitempty"`
	// if true: run the pre-receive hook
	RunPreReceive        bool   `protobuf:"varint,6,opt,name=RunPreReceive" json:"RunPreReceive,omitempty"`
	CreatedComplete      bool   `protobuf:"varint,7,opt,name=CreatedComplete" json:"CreatedComplete,omitempty"`
	Description          string `protobuf:"bytes,8,opt,name=Description" json:"Description,omitempty"`
	UserCommits          uint64 `protobuf:"varint,9,opt,name=UserCommits" json:"UserCommits,omitempty"`
	Deleted              bool   `protobuf:"varint,10,opt,name=Deleted" json:"Deleted,omitempty"`
	DeletedTimestamp     uint32 `protobuf:"varint,11,opt,name=DeletedTimestamp" json:"DeletedTimestamp,omitempty"`
	DeleteUser           string `protobuf:"bytes,12,opt,name=DeleteUser" json:"DeleteUser,omitempty"`
	LastCommit           uint32 `protobuf:"varint,13,opt,name=LastCommit" json:"LastCommit,omitempty"`
	LastCommitUser       string `protobuf:"bytes,14,opt,name=LastCommitUser" json:"LastCommitUser,omitempty"`
	Tags                 uint32 `protobuf:"varint,15,opt,name=Tags" json:"Tags,omitempty"`
	Forking              bool   `protobuf:"varint,16,opt,name=Forking" json:"Forking,omitempty"`
	ForkedFrom           uint64 `protobuf:"varint,17,opt,name=ForkedFrom" json:"ForkedFrom,omitempty"`
	BuildRoutingTagName  string `protobuf:"bytes,18,opt,name=BuildRoutingTagName" json:"BuildRoutingTagName,omitempty"`
	BuildRoutingTagValue string `protobuf:"bytes,19,opt,name=BuildRoutingTagValue" json:"BuildRoutingTagValue,omitempty"`
	ReadOnly             bool   `protobuf:"varint,20,opt,name=ReadOnly" json:"ReadOnly,omitempty"`
	CreateUser           string `protobuf:"bytes,21,opt,name=CreateUser" json:"CreateUser,omitempty"`
	DenyMessage          string `protobuf:"bytes,22,opt,name=DenyMessage" json:"DenyMessage,omitempty"`
}

func (m *SourceRepository) Reset()                    { *m = SourceRepository{} }
func (m *SourceRepository) String() string            { return proto.CompactTextString(m) }
func (*SourceRepository) ProtoMessage()               {}
func (*SourceRepository) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{22} }

func (m *SourceRepository) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *SourceRepository) GetFilePath() string {
	if m != nil {
		return m.FilePath
	}
	return ""
}

func (m *SourceRepository) GetURLs() []*SourceRepositoryURL {
	if m != nil {
		return m.URLs
	}
	return nil
}

func (m *SourceRepository) GetArtefactName() string {
	if m != nil {
		return m.ArtefactName
	}
	return ""
}

func (m *SourceRepository) GetRunPostReceive() bool {
	if m != nil {
		return m.RunPostReceive
	}
	return false
}

func (m *SourceRepository) GetRunPreReceive() bool {
	if m != nil {
		return m.RunPreReceive
	}
	return false
}

func (m *SourceRepository) GetCreatedComplete() bool {
	if m != nil {
		return m.CreatedComplete
	}
	return false
}

func (m *SourceRepository) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *SourceRepository) GetUserCommits() uint64 {
	if m != nil {
		return m.UserCommits
	}
	return 0
}

func (m *SourceRepository) GetDeleted() bool {
	if m != nil {
		return m.Deleted
	}
	return false
}

func (m *SourceRepository) GetDeletedTimestamp() uint32 {
	if m != nil {
		return m.DeletedTimestamp
	}
	return 0
}

func (m *SourceRepository) GetDeleteUser() string {
	if m != nil {
		return m.DeleteUser
	}
	return ""
}

func (m *SourceRepository) GetLastCommit() uint32 {
	if m != nil {
		return m.LastCommit
	}
	return 0
}

func (m *SourceRepository) GetLastCommitUser() string {
	if m != nil {
		return m.LastCommitUser
	}
	return ""
}

func (m *SourceRepository) GetTags() uint32 {
	if m != nil {
		return m.Tags
	}
	return 0
}

func (m *SourceRepository) GetForking() bool {
	if m != nil {
		return m.Forking
	}
	return false
}

func (m *SourceRepository) GetForkedFrom() uint64 {
	if m != nil {
		return m.ForkedFrom
	}
	return 0
}

func (m *SourceRepository) GetBuildRoutingTagName() string {
	if m != nil {
		return m.BuildRoutingTagName
	}
	return ""
}

func (m *SourceRepository) GetBuildRoutingTagValue() string {
	if m != nil {
		return m.BuildRoutingTagValue
	}
	return ""
}

func (m *SourceRepository) GetReadOnly() bool {
	if m != nil {
		return m.ReadOnly
	}
	return false
}

func (m *SourceRepository) GetCreateUser() string {
	if m != nil {
		return m.CreateUser
	}
	return ""
}

func (m *SourceRepository) GetDenyMessage() string {
	if m != nil {
		return m.DenyMessage
	}
	return ""
}

// the URL a given repository can be accessed under.
// Note: Repositories may be accessed under multiple different URLs
type SourceRepositoryURL struct {
	ID uint64 `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	// the Repository we're referring to on disk
	V2RepositoryID uint64 `protobuf:"varint,2,opt,name=V2RepositoryID" json:"V2RepositoryID,omitempty"`
	// which Host do we expose this on, e.g. "git.singingcat.net"
	Host string `protobuf:"bytes,3,opt,name=Host" json:"Host,omitempty"`
	// which path do we expose this on, e.g. "/git/foobar.git"
	Path string `protobuf:"bytes,4,opt,name=Path" json:"Path,omitempty"`
}

func (m *SourceRepositoryURL) Reset()                    { *m = SourceRepositoryURL{} }
func (m *SourceRepositoryURL) String() string            { return proto.CompactTextString(m) }
func (*SourceRepositoryURL) ProtoMessage()               {}
func (*SourceRepositoryURL) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{23} }

func (m *SourceRepositoryURL) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *SourceRepositoryURL) GetV2RepositoryID() uint64 {
	if m != nil {
		return m.V2RepositoryID
	}
	return 0
}

func (m *SourceRepositoryURL) GetHost() string {
	if m != nil {
		return m.Host
	}
	return ""
}

func (m *SourceRepositoryURL) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

type SourceRepositoryList struct {
	Repos []*SourceRepository `protobuf:"bytes,1,rep,name=Repos" json:"Repos,omitempty"`
}

func (m *SourceRepositoryList) Reset()                    { *m = SourceRepositoryList{} }
func (m *SourceRepositoryList) String() string            { return proto.CompactTextString(m) }
func (*SourceRepositoryList) ProtoMessage()               {}
func (*SourceRepositoryList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{24} }

func (m *SourceRepositoryList) GetRepos() []*SourceRepository {
	if m != nil {
		return m.Repos
	}
	return nil
}

//
// service OLDGIT {
// // deprecated and obsolete: get a repo by ID
// rpc RepoByID(ByIDRequest) returns (RepositoryInfo);
// // deprecated and obsolete: called by git post receive hook
// rpc PostReceive(PostReceiveRequest) returns (stream PostReceiveStream);
// //  deprecated and obsolete: get all repos we got access to
// rpc GetRepos(common.Void) returns (RepositoryList);
// //  deprecated and obsolete: we sometimes hit it badly...
// rpc GetCPULoad(common.Void) returns (common.CPULoad);
// //  deprecated and obsolete: fork a repo, returns ID of new repo
// rpc Fork(ByIDRequest) returns (Repository);
// }
type SetRepoFlagsRequest struct {
	RepoID         uint64 `protobuf:"varint,1,opt,name=RepoID" json:"RepoID,omitempty"`
	RunPostReceive bool   `protobuf:"varint,2,opt,name=RunPostReceive" json:"RunPostReceive,omitempty"`
	RunPreReceive  bool   `protobuf:"varint,3,opt,name=RunPreReceive" json:"RunPreReceive,omitempty"`
	ReadOnly       bool   `protobuf:"varint,4,opt,name=ReadOnly" json:"ReadOnly,omitempty"`
}

func (m *SetRepoFlagsRequest) Reset()                    { *m = SetRepoFlagsRequest{} }
func (m *SetRepoFlagsRequest) String() string            { return proto.CompactTextString(m) }
func (*SetRepoFlagsRequest) ProtoMessage()               {}
func (*SetRepoFlagsRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{25} }

func (m *SetRepoFlagsRequest) GetRepoID() uint64 {
	if m != nil {
		return m.RepoID
	}
	return 0
}

func (m *SetRepoFlagsRequest) GetRunPostReceive() bool {
	if m != nil {
		return m.RunPostReceive
	}
	return false
}

func (m *SetRepoFlagsRequest) GetRunPreReceive() bool {
	if m != nil {
		return m.RunPreReceive
	}
	return false
}

func (m *SetRepoFlagsRequest) GetReadOnly() bool {
	if m != nil {
		return m.ReadOnly
	}
	return false
}

type ForkRequest struct {
	RepositoryID   uint64               `protobuf:"varint,1,opt,name=RepositoryID" json:"RepositoryID,omitempty"`
	ArtefactName   string               `protobuf:"bytes,2,opt,name=ArtefactName" json:"ArtefactName,omitempty"`
	URL            *SourceRepositoryURL `protobuf:"bytes,3,opt,name=URL" json:"URL,omitempty"`
	Description    string               `protobuf:"bytes,4,opt,name=Description" json:"Description,omitempty"`
	CreateReadOnly bool                 `protobuf:"varint,5,opt,name=CreateReadOnly" json:"CreateReadOnly,omitempty"`
}

func (m *ForkRequest) Reset()                    { *m = ForkRequest{} }
func (m *ForkRequest) String() string            { return proto.CompactTextString(m) }
func (*ForkRequest) ProtoMessage()               {}
func (*ForkRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{26} }

func (m *ForkRequest) GetRepositoryID() uint64 {
	if m != nil {
		return m.RepositoryID
	}
	return 0
}

func (m *ForkRequest) GetArtefactName() string {
	if m != nil {
		return m.ArtefactName
	}
	return ""
}

func (m *ForkRequest) GetURL() *SourceRepositoryURL {
	if m != nil {
		return m.URL
	}
	return nil
}

func (m *ForkRequest) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *ForkRequest) GetCreateReadOnly() bool {
	if m != nil {
		return m.CreateReadOnly
	}
	return false
}

type PingResponse struct {
	PingState          *PingState `protobuf:"bytes,1,opt,name=PingState" json:"PingState,omitempty"`
	DefaultBuildDomain string     `protobuf:"bytes,2,opt,name=DefaultBuildDomain" json:"DefaultBuildDomain,omitempty"`
}

func (m *PingResponse) Reset()                    { *m = PingResponse{} }
func (m *PingResponse) String() string            { return proto.CompactTextString(m) }
func (*PingResponse) ProtoMessage()               {}
func (*PingResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{27} }

func (m *PingResponse) GetPingState() *PingState {
	if m != nil {
		return m.PingState
	}
	return nil
}

func (m *PingResponse) GetDefaultBuildDomain() string {
	if m != nil {
		return m.DefaultBuildDomain
	}
	return ""
}

type PingState struct {
	ID               uint64 `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	AssociationToken string `protobuf:"bytes,2,opt,name=AssociationToken" json:"AssociationToken,omitempty"`
	Created          uint32 `protobuf:"varint,3,opt,name=Created" json:"Created,omitempty"`
	ResponseToken    string `protobuf:"bytes,4,opt,name=ResponseToken" json:"ResponseToken,omitempty"`
}

func (m *PingState) Reset()                    { *m = PingState{} }
func (m *PingState) String() string            { return proto.CompactTextString(m) }
func (*PingState) ProtoMessage()               {}
func (*PingState) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{28} }

func (m *PingState) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *PingState) GetAssociationToken() string {
	if m != nil {
		return m.AssociationToken
	}
	return ""
}

func (m *PingState) GetCreated() uint32 {
	if m != nil {
		return m.Created
	}
	return 0
}

func (m *PingState) GetResponseToken() string {
	if m != nil {
		return m.ResponseToken
	}
	return ""
}

type CheckGitRequest struct {
	Host string `protobuf:"bytes,1,opt,name=Host" json:"Host,omitempty"`
}

func (m *CheckGitRequest) Reset()                    { *m = CheckGitRequest{} }
func (m *CheckGitRequest) String() string            { return proto.CompactTextString(m) }
func (*CheckGitRequest) ProtoMessage()               {}
func (*CheckGitRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{29} }

func (m *CheckGitRequest) GetHost() string {
	if m != nil {
		return m.Host
	}
	return ""
}

type CheckGitResponse struct {
	Success bool `protobuf:"varint,1,opt,name=Success" json:"Success,omitempty"`
}

func (m *CheckGitResponse) Reset()                    { *m = CheckGitResponse{} }
func (m *CheckGitResponse) String() string            { return proto.CompactTextString(m) }
func (*CheckGitResponse) ProtoMessage()               {}
func (*CheckGitResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{30} }

func (m *CheckGitResponse) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

type RepoFilter struct {
	Tags *RepoTagRequest `protobuf:"bytes,1,opt,name=Tags" json:"Tags,omitempty"`
}

func (m *RepoFilter) Reset()                    { *m = RepoFilter{} }
func (m *RepoFilter) String() string            { return proto.CompactTextString(m) }
func (*RepoFilter) ProtoMessage()               {}
func (*RepoFilter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{31} }

func (m *RepoFilter) GetTags() *RepoTagRequest {
	if m != nil {
		return m.Tags
	}
	return nil
}

type UpdateRepoStatusRequest struct {
	RepoID   uint64       `protobuf:"varint,1,opt,name=RepoID" json:"RepoID,omitempty"`
	ReadOnly NewRepoState `protobuf:"varint,2,opt,name=ReadOnly,enum=gitserver.NewRepoState" json:"ReadOnly,omitempty"`
	RunHooks NewRepoState `protobuf:"varint,3,opt,name=RunHooks,enum=gitserver.NewRepoState" json:"RunHooks,omitempty"`
}

func (m *UpdateRepoStatusRequest) Reset()                    { *m = UpdateRepoStatusRequest{} }
func (m *UpdateRepoStatusRequest) String() string            { return proto.CompactTextString(m) }
func (*UpdateRepoStatusRequest) ProtoMessage()               {}
func (*UpdateRepoStatusRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{32} }

func (m *UpdateRepoStatusRequest) GetRepoID() uint64 {
	if m != nil {
		return m.RepoID
	}
	return 0
}

func (m *UpdateRepoStatusRequest) GetReadOnly() NewRepoState {
	if m != nil {
		return m.ReadOnly
	}
	return NewRepoState_NOCHANGE
}

func (m *UpdateRepoStatusRequest) GetRunHooks() NewRepoState {
	if m != nil {
		return m.RunHooks
	}
	return NewRepoState_NOCHANGE
}

// ask server to execute a hook
type HookRequest struct {
	RequestKey  string   `protobuf:"bytes,1,opt,name=RequestKey" json:"RequestKey,omitempty"`
	NewRev      string   `protobuf:"bytes,2,opt,name=NewRev" json:"NewRev,omitempty"`
	OldRev      string   `protobuf:"bytes,3,opt,name=OldRev" json:"OldRev,omitempty"`
	HookName    string   `protobuf:"bytes,4,opt,name=HookName" json:"HookName,omitempty"`
	Environment []string `protobuf:"bytes,5,rep,name=Environment" json:"Environment,omitempty"`
	Args        []string `protobuf:"bytes,6,rep,name=Args" json:"Args,omitempty"`
}

func (m *HookRequest) Reset()                    { *m = HookRequest{} }
func (m *HookRequest) String() string            { return proto.CompactTextString(m) }
func (*HookRequest) ProtoMessage()               {}
func (*HookRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{33} }

func (m *HookRequest) GetRequestKey() string {
	if m != nil {
		return m.RequestKey
	}
	return ""
}

func (m *HookRequest) GetNewRev() string {
	if m != nil {
		return m.NewRev
	}
	return ""
}

func (m *HookRequest) GetOldRev() string {
	if m != nil {
		return m.OldRev
	}
	return ""
}

func (m *HookRequest) GetHookName() string {
	if m != nil {
		return m.HookName
	}
	return ""
}

func (m *HookRequest) GetEnvironment() []string {
	if m != nil {
		return m.Environment
	}
	return nil
}

func (m *HookRequest) GetArgs() []string {
	if m != nil {
		return m.Args
	}
	return nil
}

type HookResponse struct {
	ErrorMessage string `protobuf:"bytes,1,opt,name=ErrorMessage" json:"ErrorMessage,omitempty"`
	Output       string `protobuf:"bytes,2,opt,name=Output" json:"Output,omitempty"`
}

func (m *HookResponse) Reset()                    { *m = HookResponse{} }
func (m *HookResponse) String() string            { return proto.CompactTextString(m) }
func (*HookResponse) ProtoMessage()               {}
func (*HookResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{34} }

func (m *HookResponse) GetErrorMessage() string {
	if m != nil {
		return m.ErrorMessage
	}
	return ""
}

func (m *HookResponse) GetOutput() string {
	if m != nil {
		return m.Output
	}
	return ""
}

// data request to update a repo
type RepoUpdateRequest struct {
	Original    *SourceRepository `protobuf:"bytes,1,opt,name=Original" json:"Original,omitempty"`
	Description string            `protobuf:"bytes,2,opt,name=Description" json:"Description,omitempty"`
	AddURLHost  string            `protobuf:"bytes,3,opt,name=AddURLHost" json:"AddURLHost,omitempty"`
	AddURLPath  string            `protobuf:"bytes,4,opt,name=AddURLPath" json:"AddURLPath,omitempty"`
}

func (m *RepoUpdateRequest) Reset()                    { *m = RepoUpdateRequest{} }
func (m *RepoUpdateRequest) String() string            { return proto.CompactTextString(m) }
func (*RepoUpdateRequest) ProtoMessage()               {}
func (*RepoUpdateRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{35} }

func (m *RepoUpdateRequest) GetOriginal() *SourceRepository {
	if m != nil {
		return m.Original
	}
	return nil
}

func (m *RepoUpdateRequest) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *RepoUpdateRequest) GetAddURLHost() string {
	if m != nil {
		return m.AddURLHost
	}
	return ""
}

func (m *RepoUpdateRequest) GetAddURLPath() string {
	if m != nil {
		return m.AddURLPath
	}
	return ""
}

type SourceRepositoryResponse struct {
	Found      bool              `protobuf:"varint,1,opt,name=Found" json:"Found,omitempty"`
	Repository *SourceRepository `protobuf:"bytes,2,opt,name=Repository" json:"Repository,omitempty"`
}

func (m *SourceRepositoryResponse) Reset()                    { *m = SourceRepositoryResponse{} }
func (m *SourceRepositoryResponse) String() string            { return proto.CompactTextString(m) }
func (*SourceRepositoryResponse) ProtoMessage()               {}
func (*SourceRepositoryResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{36} }

func (m *SourceRepositoryResponse) GetFound() bool {
	if m != nil {
		return m.Found
	}
	return false
}

func (m *SourceRepositoryResponse) GetRepository() *SourceRepository {
	if m != nil {
		return m.Repository
	}
	return nil
}

type DenyMessageRequest struct {
	RepositoryID uint64 `protobuf:"varint,1,opt,name=RepositoryID" json:"RepositoryID,omitempty"`
	DenyMessage  string `protobuf:"bytes,2,opt,name=DenyMessage" json:"DenyMessage,omitempty"`
}

func (m *DenyMessageRequest) Reset()                    { *m = DenyMessageRequest{} }
func (m *DenyMessageRequest) String() string            { return proto.CompactTextString(m) }
func (*DenyMessageRequest) ProtoMessage()               {}
func (*DenyMessageRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{37} }

func (m *DenyMessageRequest) GetRepositoryID() uint64 {
	if m != nil {
		return m.RepositoryID
	}
	return 0
}

func (m *DenyMessageRequest) GetDenyMessage() string {
	if m != nil {
		return m.DenyMessage
	}
	return ""
}

type NumberCommitsUserRequest struct {
	UserID    string `protobuf:"bytes,1,opt,name=UserID" json:"UserID,omitempty"`
	Timestamp uint32 `protobuf:"varint,2,opt,name=Timestamp" json:"Timestamp,omitempty"`
}

func (m *NumberCommitsUserRequest) Reset()                    { *m = NumberCommitsUserRequest{} }
func (m *NumberCommitsUserRequest) String() string            { return proto.CompactTextString(m) }
func (*NumberCommitsUserRequest) ProtoMessage()               {}
func (*NumberCommitsUserRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{38} }

func (m *NumberCommitsUserRequest) GetUserID() string {
	if m != nil {
		return m.UserID
	}
	return ""
}

func (m *NumberCommitsUserRequest) GetTimestamp() uint32 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

type NumberCommitsUserResponse struct {
	Commits uint32 `protobuf:"varint,1,opt,name=Commits" json:"Commits,omitempty"`
}

func (m *NumberCommitsUserResponse) Reset()                    { *m = NumberCommitsUserResponse{} }
func (m *NumberCommitsUserResponse) String() string            { return proto.CompactTextString(m) }
func (*NumberCommitsUserResponse) ProtoMessage()               {}
func (*NumberCommitsUserResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{39} }

func (m *NumberCommitsUserResponse) GetCommits() uint32 {
	if m != nil {
		return m.Commits
	}
	return 0
}

type GetNTagRequest struct {
	RepositoryID uint64 `protobuf:"varint,1,opt,name=RepositoryID" json:"RepositoryID,omitempty"`
	Tag          uint64 `protobuf:"varint,2,opt,name=Tag" json:"Tag,omitempty"`
}

func (m *GetNTagRequest) Reset()                    { *m = GetNTagRequest{} }
func (m *GetNTagRequest) String() string            { return proto.CompactTextString(m) }
func (*GetNTagRequest) ProtoMessage()               {}
func (*GetNTagRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{40} }

func (m *GetNTagRequest) GetRepositoryID() uint64 {
	if m != nil {
		return m.RepositoryID
	}
	return 0
}

func (m *GetNTagRequest) GetTag() uint64 {
	if m != nil {
		return m.Tag
	}
	return 0
}

type AttachNTagRequest struct {
	RepositoryID uint64 `protobuf:"varint,1,opt,name=RepositoryID" json:"RepositoryID,omitempty"`
	Tag          uint64 `protobuf:"varint,2,opt,name=Tag" json:"Tag,omitempty"`
	BuildID      uint64 `protobuf:"varint,3,opt,name=BuildID" json:"BuildID,omitempty"`
}

func (m *AttachNTagRequest) Reset()                    { *m = AttachNTagRequest{} }
func (m *AttachNTagRequest) String() string            { return proto.CompactTextString(m) }
func (*AttachNTagRequest) ProtoMessage()               {}
func (*AttachNTagRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{41} }

func (m *AttachNTagRequest) GetRepositoryID() uint64 {
	if m != nil {
		return m.RepositoryID
	}
	return 0
}

func (m *AttachNTagRequest) GetTag() uint64 {
	if m != nil {
		return m.Tag
	}
	return 0
}

func (m *AttachNTagRequest) GetBuildID() uint64 {
	if m != nil {
		return m.BuildID
	}
	return 0
}

type NRepoTagID struct {
	ID           uint64 `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	RepositoryID uint64 `protobuf:"varint,2,opt,name=RepositoryID" json:"RepositoryID,omitempty"`
	Tag          uint64 `protobuf:"varint,3,opt,name=Tag" json:"Tag,omitempty"`
	BuildID      uint64 `protobuf:"varint,4,opt,name=BuildID" json:"BuildID,omitempty"`
}

func (m *NRepoTagID) Reset()                    { *m = NRepoTagID{} }
func (m *NRepoTagID) String() string            { return proto.CompactTextString(m) }
func (*NRepoTagID) ProtoMessage()               {}
func (*NRepoTagID) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{42} }

func (m *NRepoTagID) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *NRepoTagID) GetRepositoryID() uint64 {
	if m != nil {
		return m.RepositoryID
	}
	return 0
}

func (m *NRepoTagID) GetTag() uint64 {
	if m != nil {
		return m.Tag
	}
	return 0
}

func (m *NRepoTagID) GetBuildID() uint64 {
	if m != nil {
		return m.BuildID
	}
	return 0
}

type NTagResponse struct {
	NTag *NRepoTagID `protobuf:"bytes,1,opt,name=NTag" json:"NTag,omitempty"`
}

func (m *NTagResponse) Reset()                    { *m = NTagResponse{} }
func (m *NTagResponse) String() string            { return proto.CompactTextString(m) }
func (*NTagResponse) ProtoMessage()               {}
func (*NTagResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{43} }

func (m *NTagResponse) GetNTag() *NRepoTagID {
	if m != nil {
		return m.NTag
	}
	return nil
}

type GitCredentialsRequest struct {
	Args        []string `protobuf:"bytes,1,rep,name=Args" json:"Args,omitempty"`
	Environment []string `protobuf:"bytes,2,rep,name=Environment" json:"Environment,omitempty"`
	Stdin       string   `protobuf:"bytes,3,opt,name=Stdin" json:"Stdin,omitempty"`
}

func (m *GitCredentialsRequest) Reset()                    { *m = GitCredentialsRequest{} }
func (m *GitCredentialsRequest) String() string            { return proto.CompactTextString(m) }
func (*GitCredentialsRequest) ProtoMessage()               {}
func (*GitCredentialsRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{44} }

func (m *GitCredentialsRequest) GetArgs() []string {
	if m != nil {
		return m.Args
	}
	return nil
}

func (m *GitCredentialsRequest) GetEnvironment() []string {
	if m != nil {
		return m.Environment
	}
	return nil
}

func (m *GitCredentialsRequest) GetStdin() string {
	if m != nil {
		return m.Stdin
	}
	return ""
}

type GitCredentialsResponse struct {
	Stdout string `protobuf:"bytes,1,opt,name=Stdout" json:"Stdout,omitempty"`
}

func (m *GitCredentialsResponse) Reset()                    { *m = GitCredentialsResponse{} }
func (m *GitCredentialsResponse) String() string            { return proto.CompactTextString(m) }
func (*GitCredentialsResponse) ProtoMessage()               {}
func (*GitCredentialsResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{45} }

func (m *GitCredentialsResponse) GetStdout() string {
	if m != nil {
		return m.Stdout
	}
	return ""
}

func init() {
	proto.RegisterType((*GitCredentials)(nil), "gitserver.GitCredentials")
	proto.RegisterType((*InternalGitHost)(nil), "gitserver.InternalGitHost")
	proto.RegisterType((*CreateGitCredentialsRequest)(nil), "gitserver.CreateGitCredentialsRequest")
	proto.RegisterType((*RepoTagRequest)(nil), "gitserver.RepoTagRequest")
	proto.RegisterType((*CreateRepoLog)(nil), "gitserver.CreateRepoLog")
	proto.RegisterType((*GitAccessLog)(nil), "gitserver.GitAccessLog")
	proto.RegisterType((*Build)(nil), "gitserver.Build")
	proto.RegisterType((*BuildList)(nil), "gitserver.BuildList")
	proto.RegisterType((*RepositoryList)(nil), "gitserver.RepositoryList")
	proto.RegisterType((*Permission)(nil), "gitserver.Permission")
	proto.RegisterType((*Watchers)(nil), "gitserver.Watchers")
	proto.RegisterType((*Repository)(nil), "gitserver.Repository")
	proto.RegisterType((*GroupRepositoryAccess)(nil), "gitserver.GroupRepositoryAccess")
	proto.RegisterType((*UserRepositoryAccess)(nil), "gitserver.UserRepositoryAccess")
	proto.RegisterType((*PostReceiveRequest)(nil), "gitserver.PostReceiveRequest")
	proto.RegisterType((*PostReceiveStream)(nil), "gitserver.PostReceiveStream")
	proto.RegisterType((*ByIDRequest)(nil), "gitserver.ByIDRequest")
	proto.RegisterType((*RebuildRequest)(nil), "gitserver.RebuildRequest")
	proto.RegisterType((*ByURLRequest)(nil), "gitserver.ByURLRequest")
	proto.RegisterType((*RepositoryInfo)(nil), "gitserver.RepositoryInfo")
	proto.RegisterType((*GitInfo)(nil), "gitserver.GitInfo")
	proto.RegisterType((*CreateRepoRequest)(nil), "gitserver.CreateRepoRequest")
	proto.RegisterType((*SourceRepository)(nil), "gitserver.SourceRepository")
	proto.RegisterType((*SourceRepositoryURL)(nil), "gitserver.SourceRepositoryURL")
	proto.RegisterType((*SourceRepositoryList)(nil), "gitserver.SourceRepositoryList")
	proto.RegisterType((*SetRepoFlagsRequest)(nil), "gitserver.SetRepoFlagsRequest")
	proto.RegisterType((*ForkRequest)(nil), "gitserver.ForkRequest")
	proto.RegisterType((*PingResponse)(nil), "gitserver.PingResponse")
	proto.RegisterType((*PingState)(nil), "gitserver.PingState")
	proto.RegisterType((*CheckGitRequest)(nil), "gitserver.CheckGitRequest")
	proto.RegisterType((*CheckGitResponse)(nil), "gitserver.CheckGitResponse")
	proto.RegisterType((*RepoFilter)(nil), "gitserver.RepoFilter")
	proto.RegisterType((*UpdateRepoStatusRequest)(nil), "gitserver.UpdateRepoStatusRequest")
	proto.RegisterType((*HookRequest)(nil), "gitserver.HookRequest")
	proto.RegisterType((*HookResponse)(nil), "gitserver.HookResponse")
	proto.RegisterType((*RepoUpdateRequest)(nil), "gitserver.RepoUpdateRequest")
	proto.RegisterType((*SourceRepositoryResponse)(nil), "gitserver.SourceRepositoryResponse")
	proto.RegisterType((*DenyMessageRequest)(nil), "gitserver.DenyMessageRequest")
	proto.RegisterType((*NumberCommitsUserRequest)(nil), "gitserver.NumberCommitsUserRequest")
	proto.RegisterType((*NumberCommitsUserResponse)(nil), "gitserver.NumberCommitsUserResponse")
	proto.RegisterType((*GetNTagRequest)(nil), "gitserver.GetNTagRequest")
	proto.RegisterType((*AttachNTagRequest)(nil), "gitserver.AttachNTagRequest")
	proto.RegisterType((*NRepoTagID)(nil), "gitserver.NRepoTagID")
	proto.RegisterType((*NTagResponse)(nil), "gitserver.NTagResponse")
	proto.RegisterType((*GitCredentialsRequest)(nil), "gitserver.GitCredentialsRequest")
	proto.RegisterType((*GitCredentialsResponse)(nil), "gitserver.GitCredentialsResponse")
	proto.RegisterEnum("gitserver.REPOTAG", REPOTAG_name, REPOTAG_value)
	proto.RegisterEnum("gitserver.NewRepoState", NewRepoState_name, NewRepoState_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for GIT2 service

type GIT2Client interface {
	// check if there is a git server listening on that host
	CheckGitServer(ctx context.Context, in *CheckGitRequest, opts ...grpc.CallOption) (*CheckGitResponse, error)
	// get a repo by ID
	RepoByID(ctx context.Context, in *ByIDRequest, opts ...grpc.CallOption) (*SourceRepository, error)
	// get a repo by URL, error if none found
	RepoByURL(ctx context.Context, in *ByURLRequest, opts ...grpc.CallOption) (*SourceRepository, error)
	// fork a repo, returns ID of new repo
	Fork(ctx context.Context, in *ForkRequest, opts ...grpc.CallOption) (*SourceRepository, error)
	// get all repos current user got access to. (Note: This is a global list, no longer "per gitserver"
	GetRepos(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*SourceRepositoryList, error)
	// create a new bare git repo
	CreateRepo(ctx context.Context, in *CreateRepoRequest, opts ...grpc.CallOption) (*SourceRepository, error)
	SetRepoFlags(ctx context.Context, in *SetRepoFlagsRequest, opts ...grpc.CallOption) (*common.Void, error)
	// mark this repository as complete. This is limited to repobuilder only
	RepoBuilderComplete(ctx context.Context, in *ByIDRequest, opts ...grpc.CallOption) (*common.Void, error)
	// reset this repository.  This is limited to repobuilder only and specific repositories. It serves to re-use test repositories. It resets the contents to
	// "bare" (but not the URL)
	ResetRepository(ctx context.Context, in *ByIDRequest, opts ...grpc.CallOption) (*common.Void, error)
	// delete a repository. it'll be gone thereafter
	DeleteRepository(ctx context.Context, in *ByIDRequest, opts ...grpc.CallOption) (*common.Void, error)
	// get repos with specific flags
	GetReposTags(ctx context.Context, in *RepoTagRequest, opts ...grpc.CallOption) (*SourceRepositoryList, error)
	// get recent builds
	GetRecentBuilds(ctx context.Context, in *ByIDRequest, opts ...grpc.CallOption) (*BuildList, error)
	// get most recent (possibly failed) build by repositoryid
	GetLatestBuild(ctx context.Context, in *ByIDRequest, opts ...grpc.CallOption) (*Build, error)
	// get most recent successful build by repositoryID
	GetLatestSuccessfulBuild(ctx context.Context, in *ByIDRequest, opts ...grpc.CallOption) (*Build, error)
	// make repobuilder no longer read-only
	UpdateRepoStatus(ctx context.Context, in *UpdateRepoStatusRequest, opts ...grpc.CallOption) (*SourceRepository, error)
	// run a hook. this is invoked from git:/hooks/[scriptname]->git-hook binary->gRPC and subject to special restrictions,
	RunLocalHook(ctx context.Context, in *HookRequest, opts ...grpc.CallOption) (GIT2_RunLocalHookClient, error)
	// update git repository
	GitRepoUpdate(ctx context.Context, in *RepoUpdateRequest, opts ...grpc.CallOption) (*SourceRepository, error)
	// find a repo by URL, return nil if none
	FindRepoByURL(ctx context.Context, in *ByURLRequest, opts ...grpc.CallOption) (*SourceRepositoryResponse, error)
	//
	// rebuild - this does not necessarily mean the result can be stored in the build repo archive though
	// The "Rebuild" will attempt to store the result in the buildrepository under the Named BuildID. The
	// Build Repository will - normally - reject this (builds are immutable). This can, however, be useful to
	// verify if configuration changes on the buildserver result in a successful build.
	Rebuild(ctx context.Context, in *RebuildRequest, opts ...grpc.CallOption) (GIT2_RebuildClient, error)
	// set (or clear) a repository deny message
	SetDenyMessage(ctx context.Context, in *DenyMessageRequest, opts ...grpc.CallOption) (*common.Void, error)
	// get number of commits for a particular user upto a certain point of time (across all repos)
	// this answers the question: "How many commits did User push before time X?"
	// note the absense of a repository - this queries across all repositories, including deleted ones.
	GetNumberCommitsUser(ctx context.Context, in *NumberCommitsUserRequest, opts ...grpc.CallOption) (*NumberCommitsUserResponse, error)
	// rpc attach an N-tag (a number) to a build (n-tags are distinct from any other tags).
	// An N-Tag is a numeric tag. Each repository may only have at most 1 n-tag for each numeric value
	AttachNTagToBuild(ctx context.Context, in *AttachNTagRequest, opts ...grpc.CallOption) (*common.Void, error)
	// rpc get build for n-tag
	GetBuildWithNTag(ctx context.Context, in *GetNTagRequest, opts ...grpc.CallOption) (*NTagResponse, error)
	// get a repo by id
	GetRepoByID(ctx context.Context, in *ByIDRequest, opts ...grpc.CallOption) (*SourceRepository, error)
}

type gIT2Client struct {
	cc *grpc.ClientConn
}

func NewGIT2Client(cc *grpc.ClientConn) GIT2Client {
	return &gIT2Client{cc}
}

func (c *gIT2Client) CheckGitServer(ctx context.Context, in *CheckGitRequest, opts ...grpc.CallOption) (*CheckGitResponse, error) {
	out := new(CheckGitResponse)
	err := grpc.Invoke(ctx, "/gitserver.GIT2/CheckGitServer", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gIT2Client) RepoByID(ctx context.Context, in *ByIDRequest, opts ...grpc.CallOption) (*SourceRepository, error) {
	out := new(SourceRepository)
	err := grpc.Invoke(ctx, "/gitserver.GIT2/RepoByID", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gIT2Client) RepoByURL(ctx context.Context, in *ByURLRequest, opts ...grpc.CallOption) (*SourceRepository, error) {
	out := new(SourceRepository)
	err := grpc.Invoke(ctx, "/gitserver.GIT2/RepoByURL", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gIT2Client) Fork(ctx context.Context, in *ForkRequest, opts ...grpc.CallOption) (*SourceRepository, error) {
	out := new(SourceRepository)
	err := grpc.Invoke(ctx, "/gitserver.GIT2/Fork", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gIT2Client) GetRepos(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*SourceRepositoryList, error) {
	out := new(SourceRepositoryList)
	err := grpc.Invoke(ctx, "/gitserver.GIT2/GetRepos", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gIT2Client) CreateRepo(ctx context.Context, in *CreateRepoRequest, opts ...grpc.CallOption) (*SourceRepository, error) {
	out := new(SourceRepository)
	err := grpc.Invoke(ctx, "/gitserver.GIT2/CreateRepo", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gIT2Client) SetRepoFlags(ctx context.Context, in *SetRepoFlagsRequest, opts ...grpc.CallOption) (*common.Void, error) {
	out := new(common.Void)
	err := grpc.Invoke(ctx, "/gitserver.GIT2/SetRepoFlags", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gIT2Client) RepoBuilderComplete(ctx context.Context, in *ByIDRequest, opts ...grpc.CallOption) (*common.Void, error) {
	out := new(common.Void)
	err := grpc.Invoke(ctx, "/gitserver.GIT2/RepoBuilderComplete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gIT2Client) ResetRepository(ctx context.Context, in *ByIDRequest, opts ...grpc.CallOption) (*common.Void, error) {
	out := new(common.Void)
	err := grpc.Invoke(ctx, "/gitserver.GIT2/ResetRepository", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gIT2Client) DeleteRepository(ctx context.Context, in *ByIDRequest, opts ...grpc.CallOption) (*common.Void, error) {
	out := new(common.Void)
	err := grpc.Invoke(ctx, "/gitserver.GIT2/DeleteRepository", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gIT2Client) GetReposTags(ctx context.Context, in *RepoTagRequest, opts ...grpc.CallOption) (*SourceRepositoryList, error) {
	out := new(SourceRepositoryList)
	err := grpc.Invoke(ctx, "/gitserver.GIT2/GetReposTags", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gIT2Client) GetRecentBuilds(ctx context.Context, in *ByIDRequest, opts ...grpc.CallOption) (*BuildList, error) {
	out := new(BuildList)
	err := grpc.Invoke(ctx, "/gitserver.GIT2/GetRecentBuilds", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gIT2Client) GetLatestBuild(ctx context.Context, in *ByIDRequest, opts ...grpc.CallOption) (*Build, error) {
	out := new(Build)
	err := grpc.Invoke(ctx, "/gitserver.GIT2/GetLatestBuild", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gIT2Client) GetLatestSuccessfulBuild(ctx context.Context, in *ByIDRequest, opts ...grpc.CallOption) (*Build, error) {
	out := new(Build)
	err := grpc.Invoke(ctx, "/gitserver.GIT2/GetLatestSuccessfulBuild", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gIT2Client) UpdateRepoStatus(ctx context.Context, in *UpdateRepoStatusRequest, opts ...grpc.CallOption) (*SourceRepository, error) {
	out := new(SourceRepository)
	err := grpc.Invoke(ctx, "/gitserver.GIT2/UpdateRepoStatus", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gIT2Client) RunLocalHook(ctx context.Context, in *HookRequest, opts ...grpc.CallOption) (GIT2_RunLocalHookClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_GIT2_serviceDesc.Streams[0], c.cc, "/gitserver.GIT2/RunLocalHook", opts...)
	if err != nil {
		return nil, err
	}
	x := &gIT2RunLocalHookClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type GIT2_RunLocalHookClient interface {
	Recv() (*HookResponse, error)
	grpc.ClientStream
}

type gIT2RunLocalHookClient struct {
	grpc.ClientStream
}

func (x *gIT2RunLocalHookClient) Recv() (*HookResponse, error) {
	m := new(HookResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *gIT2Client) GitRepoUpdate(ctx context.Context, in *RepoUpdateRequest, opts ...grpc.CallOption) (*SourceRepository, error) {
	out := new(SourceRepository)
	err := grpc.Invoke(ctx, "/gitserver.GIT2/GitRepoUpdate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gIT2Client) FindRepoByURL(ctx context.Context, in *ByURLRequest, opts ...grpc.CallOption) (*SourceRepositoryResponse, error) {
	out := new(SourceRepositoryResponse)
	err := grpc.Invoke(ctx, "/gitserver.GIT2/FindRepoByURL", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gIT2Client) Rebuild(ctx context.Context, in *RebuildRequest, opts ...grpc.CallOption) (GIT2_RebuildClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_GIT2_serviceDesc.Streams[1], c.cc, "/gitserver.GIT2/Rebuild", opts...)
	if err != nil {
		return nil, err
	}
	x := &gIT2RebuildClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type GIT2_RebuildClient interface {
	Recv() (*HookResponse, error)
	grpc.ClientStream
}

type gIT2RebuildClient struct {
	grpc.ClientStream
}

func (x *gIT2RebuildClient) Recv() (*HookResponse, error) {
	m := new(HookResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *gIT2Client) SetDenyMessage(ctx context.Context, in *DenyMessageRequest, opts ...grpc.CallOption) (*common.Void, error) {
	out := new(common.Void)
	err := grpc.Invoke(ctx, "/gitserver.GIT2/SetDenyMessage", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gIT2Client) GetNumberCommitsUser(ctx context.Context, in *NumberCommitsUserRequest, opts ...grpc.CallOption) (*NumberCommitsUserResponse, error) {
	out := new(NumberCommitsUserResponse)
	err := grpc.Invoke(ctx, "/gitserver.GIT2/GetNumberCommitsUser", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gIT2Client) AttachNTagToBuild(ctx context.Context, in *AttachNTagRequest, opts ...grpc.CallOption) (*common.Void, error) {
	out := new(common.Void)
	err := grpc.Invoke(ctx, "/gitserver.GIT2/AttachNTagToBuild", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gIT2Client) GetBuildWithNTag(ctx context.Context, in *GetNTagRequest, opts ...grpc.CallOption) (*NTagResponse, error) {
	out := new(NTagResponse)
	err := grpc.Invoke(ctx, "/gitserver.GIT2/GetBuildWithNTag", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gIT2Client) GetRepoByID(ctx context.Context, in *ByIDRequest, opts ...grpc.CallOption) (*SourceRepository, error) {
	out := new(SourceRepository)
	err := grpc.Invoke(ctx, "/gitserver.GIT2/GetRepoByID", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for GIT2 service

type GIT2Server interface {
	// check if there is a git server listening on that host
	CheckGitServer(context.Context, *CheckGitRequest) (*CheckGitResponse, error)
	// get a repo by ID
	RepoByID(context.Context, *ByIDRequest) (*SourceRepository, error)
	// get a repo by URL, error if none found
	RepoByURL(context.Context, *ByURLRequest) (*SourceRepository, error)
	// fork a repo, returns ID of new repo
	Fork(context.Context, *ForkRequest) (*SourceRepository, error)
	// get all repos current user got access to. (Note: This is a global list, no longer "per gitserver"
	GetRepos(context.Context, *common.Void) (*SourceRepositoryList, error)
	// create a new bare git repo
	CreateRepo(context.Context, *CreateRepoRequest) (*SourceRepository, error)
	SetRepoFlags(context.Context, *SetRepoFlagsRequest) (*common.Void, error)
	// mark this repository as complete. This is limited to repobuilder only
	RepoBuilderComplete(context.Context, *ByIDRequest) (*common.Void, error)
	// reset this repository.  This is limited to repobuilder only and specific repositories. It serves to re-use test repositories. It resets the contents to
	// "bare" (but not the URL)
	ResetRepository(context.Context, *ByIDRequest) (*common.Void, error)
	// delete a repository. it'll be gone thereafter
	DeleteRepository(context.Context, *ByIDRequest) (*common.Void, error)
	// get repos with specific flags
	GetReposTags(context.Context, *RepoTagRequest) (*SourceRepositoryList, error)
	// get recent builds
	GetRecentBuilds(context.Context, *ByIDRequest) (*BuildList, error)
	// get most recent (possibly failed) build by repositoryid
	GetLatestBuild(context.Context, *ByIDRequest) (*Build, error)
	// get most recent successful build by repositoryID
	GetLatestSuccessfulBuild(context.Context, *ByIDRequest) (*Build, error)
	// make repobuilder no longer read-only
	UpdateRepoStatus(context.Context, *UpdateRepoStatusRequest) (*SourceRepository, error)
	// run a hook. this is invoked from git:/hooks/[scriptname]->git-hook binary->gRPC and subject to special restrictions,
	RunLocalHook(*HookRequest, GIT2_RunLocalHookServer) error
	// update git repository
	GitRepoUpdate(context.Context, *RepoUpdateRequest) (*SourceRepository, error)
	// find a repo by URL, return nil if none
	FindRepoByURL(context.Context, *ByURLRequest) (*SourceRepositoryResponse, error)
	//
	// rebuild - this does not necessarily mean the result can be stored in the build repo archive though
	// The "Rebuild" will attempt to store the result in the buildrepository under the Named BuildID. The
	// Build Repository will - normally - reject this (builds are immutable). This can, however, be useful to
	// verify if configuration changes on the buildserver result in a successful build.
	Rebuild(*RebuildRequest, GIT2_RebuildServer) error
	// set (or clear) a repository deny message
	SetDenyMessage(context.Context, *DenyMessageRequest) (*common.Void, error)
	// get number of commits for a particular user upto a certain point of time (across all repos)
	// this answers the question: "How many commits did User push before time X?"
	// note the absense of a repository - this queries across all repositories, including deleted ones.
	GetNumberCommitsUser(context.Context, *NumberCommitsUserRequest) (*NumberCommitsUserResponse, error)
	// rpc attach an N-tag (a number) to a build (n-tags are distinct from any other tags).
	// An N-Tag is a numeric tag. Each repository may only have at most 1 n-tag for each numeric value
	AttachNTagToBuild(context.Context, *AttachNTagRequest) (*common.Void, error)
	// rpc get build for n-tag
	GetBuildWithNTag(context.Context, *GetNTagRequest) (*NTagResponse, error)
	// get a repo by id
	GetRepoByID(context.Context, *ByIDRequest) (*SourceRepository, error)
}

func RegisterGIT2Server(s *grpc.Server, srv GIT2Server) {
	s.RegisterService(&_GIT2_serviceDesc, srv)
}

func _GIT2_CheckGitServer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckGitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GIT2Server).CheckGitServer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gitserver.GIT2/CheckGitServer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GIT2Server).CheckGitServer(ctx, req.(*CheckGitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GIT2_RepoByID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ByIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GIT2Server).RepoByID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gitserver.GIT2/RepoByID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GIT2Server).RepoByID(ctx, req.(*ByIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GIT2_RepoByURL_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ByURLRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GIT2Server).RepoByURL(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gitserver.GIT2/RepoByURL",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GIT2Server).RepoByURL(ctx, req.(*ByURLRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GIT2_Fork_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ForkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GIT2Server).Fork(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gitserver.GIT2/Fork",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GIT2Server).Fork(ctx, req.(*ForkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GIT2_GetRepos_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GIT2Server).GetRepos(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gitserver.GIT2/GetRepos",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GIT2Server).GetRepos(ctx, req.(*common.Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _GIT2_CreateRepo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateRepoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GIT2Server).CreateRepo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gitserver.GIT2/CreateRepo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GIT2Server).CreateRepo(ctx, req.(*CreateRepoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GIT2_SetRepoFlags_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetRepoFlagsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GIT2Server).SetRepoFlags(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gitserver.GIT2/SetRepoFlags",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GIT2Server).SetRepoFlags(ctx, req.(*SetRepoFlagsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GIT2_RepoBuilderComplete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ByIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GIT2Server).RepoBuilderComplete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gitserver.GIT2/RepoBuilderComplete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GIT2Server).RepoBuilderComplete(ctx, req.(*ByIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GIT2_ResetRepository_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ByIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GIT2Server).ResetRepository(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gitserver.GIT2/ResetRepository",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GIT2Server).ResetRepository(ctx, req.(*ByIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GIT2_DeleteRepository_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ByIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GIT2Server).DeleteRepository(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gitserver.GIT2/DeleteRepository",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GIT2Server).DeleteRepository(ctx, req.(*ByIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GIT2_GetReposTags_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RepoTagRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GIT2Server).GetReposTags(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gitserver.GIT2/GetReposTags",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GIT2Server).GetReposTags(ctx, req.(*RepoTagRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GIT2_GetRecentBuilds_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ByIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GIT2Server).GetRecentBuilds(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gitserver.GIT2/GetRecentBuilds",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GIT2Server).GetRecentBuilds(ctx, req.(*ByIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GIT2_GetLatestBuild_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ByIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GIT2Server).GetLatestBuild(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gitserver.GIT2/GetLatestBuild",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GIT2Server).GetLatestBuild(ctx, req.(*ByIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GIT2_GetLatestSuccessfulBuild_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ByIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GIT2Server).GetLatestSuccessfulBuild(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gitserver.GIT2/GetLatestSuccessfulBuild",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GIT2Server).GetLatestSuccessfulBuild(ctx, req.(*ByIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GIT2_UpdateRepoStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateRepoStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GIT2Server).UpdateRepoStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gitserver.GIT2/UpdateRepoStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GIT2Server).UpdateRepoStatus(ctx, req.(*UpdateRepoStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GIT2_RunLocalHook_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(HookRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(GIT2Server).RunLocalHook(m, &gIT2RunLocalHookServer{stream})
}

type GIT2_RunLocalHookServer interface {
	Send(*HookResponse) error
	grpc.ServerStream
}

type gIT2RunLocalHookServer struct {
	grpc.ServerStream
}

func (x *gIT2RunLocalHookServer) Send(m *HookResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _GIT2_GitRepoUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RepoUpdateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GIT2Server).GitRepoUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gitserver.GIT2/GitRepoUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GIT2Server).GitRepoUpdate(ctx, req.(*RepoUpdateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GIT2_FindRepoByURL_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ByURLRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GIT2Server).FindRepoByURL(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gitserver.GIT2/FindRepoByURL",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GIT2Server).FindRepoByURL(ctx, req.(*ByURLRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GIT2_Rebuild_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(RebuildRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(GIT2Server).Rebuild(m, &gIT2RebuildServer{stream})
}

type GIT2_RebuildServer interface {
	Send(*HookResponse) error
	grpc.ServerStream
}

type gIT2RebuildServer struct {
	grpc.ServerStream
}

func (x *gIT2RebuildServer) Send(m *HookResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _GIT2_SetDenyMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DenyMessageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GIT2Server).SetDenyMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gitserver.GIT2/SetDenyMessage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GIT2Server).SetDenyMessage(ctx, req.(*DenyMessageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GIT2_GetNumberCommitsUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NumberCommitsUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GIT2Server).GetNumberCommitsUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gitserver.GIT2/GetNumberCommitsUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GIT2Server).GetNumberCommitsUser(ctx, req.(*NumberCommitsUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GIT2_AttachNTagToBuild_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AttachNTagRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GIT2Server).AttachNTagToBuild(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gitserver.GIT2/AttachNTagToBuild",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GIT2Server).AttachNTagToBuild(ctx, req.(*AttachNTagRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GIT2_GetBuildWithNTag_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetNTagRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GIT2Server).GetBuildWithNTag(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gitserver.GIT2/GetBuildWithNTag",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GIT2Server).GetBuildWithNTag(ctx, req.(*GetNTagRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GIT2_GetRepoByID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ByIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GIT2Server).GetRepoByID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gitserver.GIT2/GetRepoByID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GIT2Server).GetRepoByID(ctx, req.(*ByIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _GIT2_serviceDesc = grpc.ServiceDesc{
	ServiceName: "gitserver.GIT2",
	HandlerType: (*GIT2Server)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CheckGitServer",
			Handler:    _GIT2_CheckGitServer_Handler,
		},
		{
			MethodName: "RepoByID",
			Handler:    _GIT2_RepoByID_Handler,
		},
		{
			MethodName: "RepoByURL",
			Handler:    _GIT2_RepoByURL_Handler,
		},
		{
			MethodName: "Fork",
			Handler:    _GIT2_Fork_Handler,
		},
		{
			MethodName: "GetRepos",
			Handler:    _GIT2_GetRepos_Handler,
		},
		{
			MethodName: "CreateRepo",
			Handler:    _GIT2_CreateRepo_Handler,
		},
		{
			MethodName: "SetRepoFlags",
			Handler:    _GIT2_SetRepoFlags_Handler,
		},
		{
			MethodName: "RepoBuilderComplete",
			Handler:    _GIT2_RepoBuilderComplete_Handler,
		},
		{
			MethodName: "ResetRepository",
			Handler:    _GIT2_ResetRepository_Handler,
		},
		{
			MethodName: "DeleteRepository",
			Handler:    _GIT2_DeleteRepository_Handler,
		},
		{
			MethodName: "GetReposTags",
			Handler:    _GIT2_GetReposTags_Handler,
		},
		{
			MethodName: "GetRecentBuilds",
			Handler:    _GIT2_GetRecentBuilds_Handler,
		},
		{
			MethodName: "GetLatestBuild",
			Handler:    _GIT2_GetLatestBuild_Handler,
		},
		{
			MethodName: "GetLatestSuccessfulBuild",
			Handler:    _GIT2_GetLatestSuccessfulBuild_Handler,
		},
		{
			MethodName: "UpdateRepoStatus",
			Handler:    _GIT2_UpdateRepoStatus_Handler,
		},
		{
			MethodName: "GitRepoUpdate",
			Handler:    _GIT2_GitRepoUpdate_Handler,
		},
		{
			MethodName: "FindRepoByURL",
			Handler:    _GIT2_FindRepoByURL_Handler,
		},
		{
			MethodName: "SetDenyMessage",
			Handler:    _GIT2_SetDenyMessage_Handler,
		},
		{
			MethodName: "GetNumberCommitsUser",
			Handler:    _GIT2_GetNumberCommitsUser_Handler,
		},
		{
			MethodName: "AttachNTagToBuild",
			Handler:    _GIT2_AttachNTagToBuild_Handler,
		},
		{
			MethodName: "GetBuildWithNTag",
			Handler:    _GIT2_GetBuildWithNTag_Handler,
		},
		{
			MethodName: "GetRepoByID",
			Handler:    _GIT2_GetRepoByID_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "RunLocalHook",
			Handler:       _GIT2_RunLocalHook_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "Rebuild",
			Handler:       _GIT2_Rebuild_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "golang.conradwood.net/apis/gitserver/gitserver.proto",
}

// Client API for GITCredentials service

type GITCredentialsClient interface {
	// called by client if git calls it
	GitInvoked(ctx context.Context, in *GitCredentialsRequest, opts ...grpc.CallOption) (*GitCredentialsResponse, error)
	// create git credentials
	CreateGitCredentials(ctx context.Context, in *CreateGitCredentialsRequest, opts ...grpc.CallOption) (*common.Void, error)
}

type gITCredentialsClient struct {
	cc *grpc.ClientConn
}

func NewGITCredentialsClient(cc *grpc.ClientConn) GITCredentialsClient {
	return &gITCredentialsClient{cc}
}

func (c *gITCredentialsClient) GitInvoked(ctx context.Context, in *GitCredentialsRequest, opts ...grpc.CallOption) (*GitCredentialsResponse, error) {
	out := new(GitCredentialsResponse)
	err := grpc.Invoke(ctx, "/gitserver.GITCredentials/GitInvoked", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gITCredentialsClient) CreateGitCredentials(ctx context.Context, in *CreateGitCredentialsRequest, opts ...grpc.CallOption) (*common.Void, error) {
	out := new(common.Void)
	err := grpc.Invoke(ctx, "/gitserver.GITCredentials/CreateGitCredentials", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for GITCredentials service

type GITCredentialsServer interface {
	// called by client if git calls it
	GitInvoked(context.Context, *GitCredentialsRequest) (*GitCredentialsResponse, error)
	// create git credentials
	CreateGitCredentials(context.Context, *CreateGitCredentialsRequest) (*common.Void, error)
}

func RegisterGITCredentialsServer(s *grpc.Server, srv GITCredentialsServer) {
	s.RegisterService(&_GITCredentials_serviceDesc, srv)
}

func _GITCredentials_GitInvoked_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GitCredentialsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GITCredentialsServer).GitInvoked(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gitserver.GITCredentials/GitInvoked",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GITCredentialsServer).GitInvoked(ctx, req.(*GitCredentialsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GITCredentials_CreateGitCredentials_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateGitCredentialsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GITCredentialsServer).CreateGitCredentials(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gitserver.GITCredentials/CreateGitCredentials",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GITCredentialsServer).CreateGitCredentials(ctx, req.(*CreateGitCredentialsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _GITCredentials_serviceDesc = grpc.ServiceDesc{
	ServiceName: "gitserver.GITCredentials",
	HandlerType: (*GITCredentialsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GitInvoked",
			Handler:    _GITCredentials_GitInvoked_Handler,
		},
		{
			MethodName: "CreateGitCredentials",
			Handler:    _GITCredentials_CreateGitCredentials_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "golang.conradwood.net/apis/gitserver/gitserver.proto",
}

func init() {
	proto.RegisterFile("golang.conradwood.net/apis/gitserver/gitserver.proto", fileDescriptor0)
}

var fileDescriptor0 = []byte{
	// 2610 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xa4, 0x59, 0x4b, 0x77, 0x1b, 0x49,
	0x15, 0x9e, 0x96, 0x64, 0x5b, 0xbe, 0x7a, 0x58, 0x6e, 0xcb, 0x49, 0x47, 0x33, 0x13, 0x3c, 0x4d,
	0xc8, 0x31, 0x61, 0xf0, 0x64, 0x94, 0xc9, 0x3c, 0x08, 0x73, 0xe6, 0xc8, 0x7a, 0x45, 0x41, 0xb1,
	0x45, 0x4b, 0x4e, 0x38, 0xb3, 0xf1, 0xe9, 0xa8, 0xcb, 0x72, 0x13, 0xa9, 0x5b, 0x74, 0x57, 0x3b,
	0xf1, 0x8e, 0x33, 0x2c, 0xd8, 0xb0, 0x00, 0x36, 0x9c, 0x03, 0x3b, 0xf6, 0xc3, 0x63, 0xc9, 0x92,
	0x9f, 0xc0, 0x86, 0x3f, 0xc0, 0x7f, 0x60, 0xcd, 0xa9, 0x97, 0xba, 0xfa, 0x21, 0xd9, 0x09, 0x1b,
	0xbb, 0xef, 0xad, 0x5b, 0xb7, 0x6e, 0xdd, 0x57, 0x7d, 0x55, 0x82, 0x4f, 0x26, 0xee, 0xd4, 0x74,
	0x26, 0x07, 0x63, 0xd7, 0xf1, 0x4c, 0xeb, 0x95, 0xeb, 0x5a, 0x07, 0x0e, 0xc2, 0x1f, 0x99, 0x73,
	0xdb, 0xff, 0x68, 0x62, 0x63, 0x1f, 0x79, 0x17, 0xc8, 0x0b, 0xbf, 0x0e, 0xe6, 0x9e, 0x8b, 0x5d,
	0x75, 0x73, 0xc1, 0xa8, 0x1d, 0xac, 0x50, 0x30, 0x76, 0x67, 0x33, 0xd7, 0xe1, 0xff, 0xd8, 0xd4,
	0xda, 0xbd, 0x15, 0xf2, 0x66, 0x80, 0xcf, 0xe9, 0x1f, 0x26, 0xab, 0xff, 0x4d, 0x81, 0x72, 0xd7,
	0xc6, 0x4d, 0x0f, 0x59, 0xc8, 0xc1, 0xb6, 0x39, 0xf5, 0xd5, 0x32, 0x64, 0x7a, 0x2d, 0x4d, 0xd9,
	0x53, 0xf6, 0x73, 0x46, 0xa6, 0xd7, 0x52, 0x6f, 0xc0, 0xfa, 0x89, 0x8f, 0xbc, 0x5e, 0x4b, 0xcb,
	0xec, 0x29, 0xfb, 0x9b, 0x06, 0xa7, 0x54, 0x15, 0x72, 0x8f, 0x5d, 0x1f, 0x6b, 0x59, 0xca, 0xa5,
	0xdf, 0x84, 0x37, 0x30, 0xf1, 0xb9, 0x96, 0x63, 0x3c, 0xf2, 0xad, 0xd6, 0x20, 0x4f, 0x66, 0x38,
	0xe6, 0x0c, 0x69, 0x6b, 0x94, 0xbf, 0xa0, 0xc9, 0xd8, 0xc0, 0xf4, 0xfd, 0x57, 0xae, 0x67, 0x69,
	0xeb, 0x6c, 0x4c, 0xd0, 0x64, 0xdd, 0xf6, 0xeb, 0xb9, 0xed, 0x5d, 0x6a, 0x1b, 0x7b, 0xca, 0x7e,
	0xc9, 0xe0, 0x94, 0xfe, 0x14, 0xb6, 0x7a, 0x0e, 0x26, 0x0a, 0xa6, 0x5d, 0x1b, 0xd3, 0x65, 0xe3,
	0x26, 0x0b, 0xd3, 0x32, 0x92, 0x69, 0xa1, 0xba, 0x6c, 0x44, 0xdd, 0x6f, 0x14, 0x78, 0xb7, 0xe9,
	0x21, 0x13, 0xa3, 0xa8, 0x1f, 0x0c, 0xf4, 0x8b, 0x00, 0xf9, 0x58, 0x7d, 0x04, 0x05, 0x89, 0x4b,
	0x17, 0x29, 0xd4, 0x6f, 0x1d, 0x84, 0xf1, 0x8a, 0x4d, 0x93, 0xa5, 0xd5, 0xfb, 0xb0, 0x33, 0x22,
	0xba, 0x89, 0x05, 0x0d, 0x5f, 0x98, 0x4d, 0xed, 0xca, 0x1b, 0x69, 0x43, 0xba, 0x0e, 0x65, 0x03,
	0xcd, 0xdd, 0x91, 0x39, 0x11, 0x06, 0x54, 0x20, 0x3b, 0x32, 0x27, 0x74, 0xe1, 0x92, 0x41, 0x3e,
	0xf5, 0x6f, 0x33, 0x50, 0x62, 0x26, 0x13, 0xd1, 0xbe, 0x3b, 0x49, 0x38, 0x40, 0x87, 0x22, 0x19,
	0xf2, 0x6d, 0xec, 0x7a, 0x97, 0x3c, 0x72, 0x39, 0x23, 0xc2, 0x93, 0xe2, 0x9a, 0x8d, 0xc4, 0x55,
	0x83, 0x8d, 0xa6, 0xeb, 0x60, 0xf4, 0x1a, 0xf3, 0x30, 0x0a, 0x92, 0xcc, 0x68, 0x8c, 0xb1, 0xed,
	0x3a, 0x34, 0x8e, 0x25, 0x83, 0x53, 0x64, 0xc6, 0x30, 0x18, 0x8f, 0x91, 0xef, 0xd3, 0x20, 0xe6,
	0x0d, 0x41, 0x12, 0x3b, 0xda, 0x9e, 0xe7, 0x7a, 0x4f, 0x91, 0xef, 0x9b, 0x13, 0x44, 0x23, 0xb9,
	0x69, 0x44, 0x78, 0x74, 0x36, 0x36, 0x3d, 0x8c, 0x2c, 0x2d, 0x4f, 0xd5, 0x0a, 0x92, 0x64, 0x47,
	0xc7, 0x76, 0x6c, 0xff, 0x1c, 0x59, 0xda, 0x26, 0x1d, 0x5a, 0xd0, 0xea, 0x3d, 0xa8, 0x34, 0x7c,
	0xdf, 0x1d, 0xdb, 0x26, 0x31, 0x61, 0xe4, 0xbe, 0x44, 0x8e, 0x06, 0x54, 0x7b, 0x82, 0xaf, 0xff,
	0x5b, 0x81, 0x62, 0xd7, 0xc6, 0x0d, 0x6a, 0x53, 0x9a, 0xbb, 0xaa, 0xb0, 0xf6, 0xdc, 0xb3, 0x31,
	0xe2, 0x81, 0x61, 0x84, 0xe4, 0xa0, 0x5c, 0xc4, 0x41, 0xef, 0xc1, 0xe6, 0xc8, 0x9e, 0x21, 0x1f,
	0x9b, 0xb3, 0x39, 0xdd, 0x70, 0xc9, 0x08, 0x19, 0xea, 0xcf, 0xa1, 0x32, 0x74, 0x03, 0x6f, 0x8c,
	0x42, 0x67, 0xd3, 0x6d, 0x17, 0xea, 0xef, 0x4a, 0x49, 0x13, 0x17, 0x39, 0xfc, 0xe0, 0x8f, 0xdf,
	0xdc, 0x5a, 0x0f, 0x6c, 0x07, 0x7f, 0xfa, 0xc9, 0x9f, 0xbf, 0xb9, 0xb5, 0xe3, 0xd3, 0x71, 0x6f,
	0x31, 0x7e, 0x60, 0x5b, 0x46, 0x42, 0xaf, 0xfe, 0x1f, 0x05, 0xd6, 0x0e, 0x03, 0x7b, 0x6a, 0xbd,
	0x55, 0x02, 0xdc, 0x06, 0x68, 0xba, 0xb3, 0x99, 0x8d, 0x1f, 0x9b, 0xfe, 0x39, 0x4f, 0x02, 0x89,
	0x43, 0xf6, 0x7f, 0xe8, 0x99, 0xce, 0x58, 0x94, 0x33, 0xa7, 0xc8, 0xbc, 0xbe, 0x3b, 0x11, 0x21,
	0x65, 0x25, 0x2d, 0x71, 0x24, 0xbf, 0xad, 0x2f, 0xf7, 0xdb, 0x46, 0xdc, 0x6f, 0x52, 0x12, 0xe5,
	0x23, 0x49, 0xa4, 0x3f, 0x84, 0x4d, 0xba, 0xc9, 0xbe, 0xed, 0x63, 0x75, 0x1f, 0xd6, 0x29, 0x41,
	0x2a, 0x31, 0xbb, 0x5f, 0xa8, 0x57, 0x24, 0xa7, 0xd2, 0x01, 0x83, 0x8f, 0xeb, 0x5f, 0xb2, 0x4a,
	0x62, 0xdb, 0xa5, 0x73, 0x7f, 0x00, 0x6b, 0x94, 0xc3, 0xa7, 0xee, 0x4a, 0x53, 0x43, 0x49, 0x83,
	0xc9, 0xe8, 0x16, 0xc0, 0x00, 0x79, 0x33, 0xdb, 0xf7, 0x49, 0x8a, 0xab, 0x90, 0x33, 0x90, 0x69,
	0x51, 0x0f, 0xe7, 0x0d, 0xfa, 0xbd, 0x24, 0x6b, 0x34, 0xd8, 0x68, 0xbf, 0x46, 0xe3, 0x00, 0x23,
	0xea, 0xd2, 0xbc, 0x21, 0x48, 0xa2, 0x83, 0x98, 0x41, 0xbd, 0x99, 0x37, 0xe8, 0xb7, 0x7e, 0x01,
	0xf9, 0xe7, 0x26, 0x1e, 0x9f, 0x23, 0xef, 0xfa, 0x8d, 0x37, 0x1e, 0xdb, 0x6c, 0x7a, 0x6c, 0x8f,
	0x5c, 0x6c, 0x9f, 0x5d, 0xe2, 0xcb, 0x39, 0xa2, 0x2b, 0x96, 0x0c, 0x89, 0xa3, 0x7f, 0xab, 0x00,
	0x84, 0x13, 0x12, 0x4b, 0xd7, 0x20, 0x4f, 0x46, 0x8f, 0x48, 0xcf, 0x66, 0x8b, 0x2f, 0x68, 0xb2,
	0xc1, 0xe3, 0x57, 0x8e, 0xd4, 0x38, 0x04, 0x49, 0x0c, 0x6b, 0x78, 0x18, 0x9d, 0x99, 0x63, 0x4c,
	0x67, 0xb2, 0xb4, 0x89, 0xf0, 0xd4, 0x87, 0xb2, 0x5b, 0x69, 0xf2, 0x44, 0x03, 0x11, 0x0e, 0x1a,
	0x92, 0xa0, 0xfe, 0x2b, 0x05, 0x76, 0xbb, 0x9e, 0x1b, 0xcc, 0x43, 0xa3, 0x59, 0x39, 0xa7, 0x79,
	0x8d, 0xc8, 0x2c, 0x72, 0x9e, 0x53, 0xc4, 0x6c, 0xaa, 0x20, 0x34, 0x9b, 0x93, 0x8b, 0xd8, 0xe6,
	0xd2, 0x62, 0xbb, 0x26, 0xc5, 0x56, 0xff, 0xa5, 0x02, 0x55, 0x12, 0x84, 0xb7, 0x36, 0x62, 0x59,
	0xcf, 0xbd, 0xbe, 0x09, 0xbf, 0x55, 0x40, 0x1d, 0xb8, 0x3e, 0x36, 0xd0, 0x18, 0xd9, 0x17, 0x48,
	0x1c, 0x12, 0x77, 0xa0, 0x44, 0x96, 0x68, 0xd9, 0x1e, 0x1a, 0xd3, 0x96, 0xa3, 0x50, 0xfd, 0x51,
	0x26, 0x39, 0x4a, 0x0c, 0x74, 0xc6, 0x23, 0x4a, 0x3e, 0xd5, 0x3d, 0x28, 0x1c, 0x4f, 0x2d, 0x03,
	0x5d, 0xd8, 0x34, 0x1e, 0xcc, 0x2a, 0x99, 0x45, 0x24, 0x8e, 0xd0, 0xab, 0x85, 0x04, 0x8b, 0xa9,
	0xcc, 0xd2, 0x77, 0x60, 0x5b, 0xb2, 0x68, 0x88, 0x3d, 0x64, 0xce, 0xf4, 0xf7, 0xa1, 0x70, 0x78,
	0xd9, 0x6b, 0x09, 0xfb, 0x62, 0x0e, 0xd2, 0x0d, 0x52, 0x9c, 0x2f, 0x68, 0xbd, 0xa6, 0x4b, 0x90,
	0xa3, 0xb3, 0xfd, 0x7a, 0x3c, 0x0d, 0x2c, 0x44, 0xeb, 0x79, 0x38, 0xf6, 0xec, 0x39, 0xf6, 0xb5,
	0xcc, 0x5e, 0x76, 0x7f, 0xd3, 0x48, 0x1b, 0xd2, 0xf7, 0xa0, 0x78, 0x78, 0x79, 0x62, 0xf4, 0xa5,
	0x83, 0xf3, 0xc4, 0xe8, 0x73, 0x4f, 0x90, 0x4f, 0xbd, 0x2b, 0xb7, 0x84, 0x9e, 0x73, 0xe6, 0x92,
	0x74, 0x94, 0xfa, 0xb4, 0x92, 0x48, 0x47, 0xa9, 0x2f, 0x48, 0x82, 0xfa, 0xef, 0x14, 0xd8, 0xe8,
	0xda, 0x98, 0xaa, 0x88, 0x97, 0xa3, 0xb2, 0xf2, 0xac, 0x8d, 0x96, 0xf2, 0x6d, 0xc8, 0x91, 0x2f,
	0xea, 0xf7, 0x42, 0x1d, 0x0e, 0x28, 0x32, 0xa3, 0x19, 0x46, 0xf9, 0x24, 0x69, 0x9f, 0x21, 0x6f,
	0xe1, 0xf8, 0x92, 0x21, 0x48, 0xb1, 0xb9, 0xb5, 0x70, 0x73, 0xff, 0x50, 0x60, 0x3b, 0x44, 0x05,
	0xc2, 0x09, 0xf1, 0x9a, 0x54, 0x52, 0x6a, 0xf2, 0x3e, 0xd3, 0x95, 0xa1, 0x46, 0xdc, 0x5e, 0x71,
	0x4a, 0x11, 0xe7, 0x12, 0x51, 0x92, 0x14, 0x2d, 0xe4, 0x53, 0xbf, 0x4b, 0x69, 0x23, 0xb1, 0xd4,
	0x0f, 0x61, 0xbb, 0xe9, 0xce, 0xe6, 0x53, 0x84, 0x51, 0xc7, 0xf5, 0x58, 0x99, 0xf0, 0xf4, 0x4e,
	0x0e, 0xe8, 0xbf, 0x5f, 0x4f, 0x9e, 0x9a, 0x69, 0x4d, 0xa9, 0x63, 0x4f, 0x11, 0x05, 0x98, 0xbc,
	0x29, 0x09, 0x5a, 0xad, 0x43, 0xee, 0xc4, 0xe8, 0xfb, 0x5a, 0x96, 0x76, 0xf6, 0xab, 0xf6, 0x40,
	0x65, 0xaf, 0xd5, 0xae, 0xee, 0x42, 0xd9, 0x08, 0x1c, 0x29, 0xbd, 0x79, 0x35, 0xc6, 0xb8, 0xb4,
	0xfe, 0x02, 0x67, 0xe0, 0x21, 0x21, 0xc6, 0x80, 0x50, 0x94, 0xa9, 0xee, 0xc3, 0x16, 0x8b, 0x90,
	0x25, 0x5c, 0x40, 0xcf, 0xc1, 0xbc, 0x11, 0x67, 0xc7, 0x1d, 0x9c, 0x4f, 0x3a, 0x78, 0x0f, 0x0a,
	0x24, 0x45, 0xd8, 0x79, 0xed, 0x53, 0x7c, 0x94, 0x33, 0x64, 0x16, 0x49, 0x9e, 0x16, 0x22, 0xda,
	0x2c, 0x8a, 0x8c, 0xf2, 0x86, 0x20, 0x09, 0x78, 0xe2, 0x9f, 0xe1, 0x81, 0x5c, 0xa0, 0xf9, 0x95,
	0xe0, 0x93, 0x93, 0x84, 0xf1, 0x68, 0xa2, 0x16, 0xd9, 0x69, 0x1f, 0x72, 0x28, 0x1a, 0x30, 0x7d,
	0xcc, 0x16, 0xd5, 0x4a, 0xec, 0xa4, 0x09, 0x39, 0xc4, 0x83, 0x21, 0x45, 0x75, 0x94, 0xa9, 0x8e,
	0x18, 0x97, 0xb4, 0xc0, 0x91, 0x39, 0xf1, 0xb5, 0x2d, 0xaa, 0x81, 0x7e, 0x93, 0x1d, 0x74, 0x5c,
	0xef, 0xa5, 0xed, 0x4c, 0xb4, 0x0a, 0xdb, 0x01, 0x27, 0xc9, 0xaa, 0xe4, 0x13, 0x59, 0x1d, 0xcf,
	0x9d, 0x69, 0xdb, 0x74, 0xf3, 0x12, 0x87, 0x74, 0x0f, 0x86, 0x06, 0xdc, 0x00, 0xdb, 0xce, 0x64,
	0x64, 0x4e, 0x68, 0x88, 0x55, 0xba, 0x74, 0xda, 0x90, 0x5a, 0x87, 0x6a, 0x8c, 0xfd, 0xcc, 0x9c,
	0x06, 0x48, 0xdb, 0xa1, 0x53, 0x52, 0xc7, 0xd8, 0x31, 0x69, 0x5a, 0xc7, 0xce, 0xf4, 0x52, 0xab,
	0x52, 0x03, 0x17, 0x34, 0x45, 0x57, 0x34, 0xa8, 0x74, 0xcf, 0xbb, 0x1c, 0x5d, 0x2d, 0x38, 0x2c,
	0xc2, 0xce, 0xa5, 0x80, 0x51, 0x37, 0x44, 0x84, 0x17, 0x2c, 0x3d, 0x80, 0x9d, 0x94, 0xe4, 0x4d,
	0x94, 0xc5, 0x5d, 0x28, 0x3f, 0xab, 0xa7, 0x80, 0xbd, 0x18, 0xf7, 0xba, 0xf7, 0x35, 0xbd, 0x07,
	0xd5, 0xf8, 0xb2, 0x14, 0x3d, 0x7d, 0x1c, 0x45, 0x4f, 0xab, 0xd0, 0xac, 0xc0, 0x50, 0x7f, 0x50,
	0x60, 0x67, 0x88, 0x30, 0x21, 0x3a, 0x53, 0x73, 0xb2, 0xb8, 0x53, 0x85, 0xc7, 0xa3, 0x12, 0x39,
	0x1e, 0x93, 0xd5, 0x96, 0xb9, 0x5e, 0xb5, 0x65, 0xd3, 0xaa, 0x4d, 0x8e, 0x4e, 0x2e, 0x1a, 0x1d,
	0xfd, 0x5f, 0x0a, 0x14, 0x48, 0xba, 0x48, 0x6d, 0xf2, 0xca, 0x26, 0x1e, 0xef, 0x17, 0x99, 0xe5,
	0xad, 0x34, 0xfb, 0xd6, 0xad, 0x34, 0x97, 0xac, 0xf4, 0xbb, 0x50, 0x16, 0x7d, 0x9d, 0xef, 0x86,
	0xf7, 0xa0, 0x28, 0x57, 0xf7, 0xa0, 0x38, 0xb0, 0x9d, 0x89, 0x81, 0xfc, 0xb9, 0xeb, 0xf8, 0x24,
	0xa3, 0x37, 0x09, 0x3d, 0xc4, 0x26, 0x46, 0xfc, 0x68, 0xab, 0xca, 0x48, 0x4b, 0x8c, 0x19, 0xa1,
	0x98, 0x7a, 0x00, 0x6a, 0x0b, 0x9d, 0x99, 0xc1, 0x14, 0xd3, 0x84, 0x6f, 0xb9, 0x33, 0xd3, 0x76,
	0xf8, 0x4e, 0x53, 0x46, 0xf4, 0x5f, 0x2b, 0xd2, 0x22, 0x89, 0xd4, 0x4c, 0xbb, 0xa4, 0x65, 0xd2,
	0x2f, 0x69, 0xf4, 0xda, 0xc9, 0x9a, 0x20, 0xbf, 0xa0, 0x0b, 0x92, 0x61, 0x1b, 0xb6, 0x27, 0xa6,
	0x22, 0x27, 0xb0, 0x8d, 0xc4, 0xd4, 0xbf, 0x07, 0x5b, 0xcd, 0x73, 0x34, 0x7e, 0xd9, 0xb5, 0xb1,
	0x08, 0xaa, 0xc8, 0x78, 0x25, 0xcc, 0x78, 0xfd, 0x43, 0xa8, 0x84, 0x62, 0xdc, 0x51, 0xd2, 0xd5,
	0x43, 0x89, 0x5e, 0x3d, 0x1e, 0x31, 0x78, 0xd0, 0xb1, 0xa7, 0x18, 0x79, 0xea, 0x0f, 0x79, 0x8b,
	0x4a, 0xbe, 0x01, 0x44, 0xaf, 0xec, 0xac, 0x7b, 0xe9, 0x7f, 0x52, 0xe0, 0xe6, 0xc9, 0xdc, 0xe2,
	0x07, 0x32, 0xf1, 0x50, 0x70, 0x65, 0x05, 0x3c, 0x90, 0x72, 0x96, 0x78, 0xaa, 0x5c, 0xbf, 0x29,
	0x2d, 0x43, 0x51, 0x17, 0x53, 0x85, 0xa4, 0x56, 0x43, 0x26, 0x05, 0xce, 0x63, 0xd7, 0x7d, 0xe9,
	0x53, 0xdf, 0xad, 0x9c, 0xc4, 0x05, 0xf5, 0xbf, 0x2a, 0x50, 0x20, 0x5f, 0xc2, 0xa2, 0xdb, 0x64,
	0xab, 0xf4, 0xf3, 0x27, 0x48, 0xc0, 0x47, 0x89, 0x43, 0x2c, 0x66, 0xa0, 0x4f, 0x40, 0x18, 0x46,
	0x11, 0x3e, 0x83, 0x8b, 0x02, 0xd2, 0x32, 0x8a, 0x54, 0x1f, 0x51, 0x2f, 0x9d, 0xac, 0x0b, 0x9a,
	0xe4, 0x7c, 0xdb, 0xb9, 0xb0, 0x3d, 0xd7, 0x99, 0x21, 0x07, 0x6b, 0x6b, 0x14, 0xd3, 0xc9, 0x2c,
	0x12, 0xba, 0x86, 0x37, 0xf1, 0xb5, 0x75, 0x3a, 0x44, 0xbf, 0xf5, 0x27, 0x50, 0x64, 0x06, 0xf3,
	0xb0, 0xc5, 0x1f, 0x17, 0x94, 0x94, 0xc7, 0x05, 0x62, 0x5d, 0x80, 0xe7, 0x81, 0x78, 0x0b, 0xe2,
	0x94, 0xfe, 0x17, 0x05, 0xb6, 0x89, 0x57, 0x44, 0x7c, 0x98, 0x0f, 0x3e, 0x83, 0xfc, 0xb1, 0x67,
	0x4f, 0x6c, 0xc7, 0x9c, 0xf2, 0x20, 0xaf, 0xec, 0x72, 0x0b, 0xe1, 0x78, 0x11, 0x67, 0x92, 0x45,
	0x7c, 0x1b, 0xa0, 0x61, 0x59, 0x27, 0x46, 0x5f, 0xea, 0xc1, 0x12, 0x27, 0x1c, 0x97, 0xfa, 0xb1,
	0xc4, 0xd1, 0x67, 0xa0, 0x25, 0xd6, 0x17, 0x8e, 0xa8, 0xc2, 0x5a, 0xc7, 0x0d, 0x1c, 0x71, 0x3b,
	0x65, 0x84, 0xfa, 0x28, 0x02, 0x6d, 0x33, 0x57, 0x6f, 0x47, 0x06, 0xb8, 0x5f, 0x93, 0x3e, 0xb0,
	0x38, 0x8a, 0xde, 0xa4, 0x4b, 0xc6, 0xce, 0xb5, 0x4c, 0xf2, 0x5c, 0x1b, 0x80, 0x76, 0x14, 0xcc,
	0x5e, 0x2c, 0x80, 0x0a, 0xbb, 0x51, 0x2d, 0xea, 0x82, 0x03, 0x65, 0x65, 0xf9, 0xdb, 0x41, 0x26,
	0xf6, 0x76, 0xa0, 0x3f, 0x84, 0x5b, 0x29, 0x1a, 0xc3, 0xea, 0x16, 0x20, 0x49, 0xe1, 0x8d, 0x85,
	0x91, 0x7a, 0x07, 0xca, 0x5d, 0x84, 0x8f, 0xa4, 0xb7, 0xb6, 0xeb, 0x6c, 0x90, 0xbf, 0xc7, 0xb1,
	0x43, 0x96, 0xbe, 0xc7, 0x8d, 0x61, 0xbb, 0x81, 0xb1, 0x39, 0x3e, 0xff, 0xbf, 0x55, 0x11, 0x63,
	0x69, 0x7b, 0x5d, 0x5c, 0xeb, 0x05, 0xa9, 0x4f, 0x01, 0x8e, 0x78, 0x9b, 0xe9, 0xb5, 0xde, 0xea,
	0xbd, 0x87, 0xaf, 0x96, 0x4d, 0x5d, 0x2d, 0x17, 0x5d, 0xed, 0x0b, 0x28, 0xb2, 0xcd, 0x70, 0x27,
	0x7e, 0x1f, 0x72, 0x47, 0xe2, 0x15, 0x32, 0x7a, 0x43, 0x0a, 0x8d, 0x32, 0xa8, 0x88, 0x3e, 0x86,
	0xdd, 0xf4, 0x97, 0x54, 0x51, 0xd3, 0x4a, 0x58, 0xd3, 0xf1, 0x4e, 0x90, 0x49, 0x76, 0x82, 0x2a,
	0xac, 0x0d, 0xb1, 0x65, 0x8b, 0x4b, 0x06, 0x23, 0xf4, 0xfb, 0x70, 0x23, 0xbe, 0x08, 0xb7, 0xf4,
	0x06, 0xac, 0x0f, 0xb1, 0xe5, 0x06, 0xa2, 0xed, 0x73, 0xea, 0xde, 0x3f, 0x15, 0xd8, 0x30, 0xda,
	0x83, 0xe3, 0x51, 0xa3, 0xab, 0x96, 0x60, 0xf3, 0xe4, 0xa8, 0xd5, 0xee, 0xf4, 0x8e, 0xda, 0xad,
	0xca, 0x3b, 0xea, 0x2d, 0xd8, 0x1d, 0x36, 0x4f, 0x3b, 0x3d, 0xe3, 0xe9, 0xf3, 0x86, 0xd1, 0x3e,
	0x1d, 0x8e, 0x9e, 0x3e, 0xa8, 0xf7, 0x3f, 0x7e, 0xf8, 0xb3, 0x8a, 0xa2, 0xde, 0x84, 0x9d, 0x61,
	0xf3, 0xb4, 0x7f, 0xdc, 0x68, 0xb5, 0x0d, 0x69, 0x20, 0xa3, 0x56, 0xa1, 0x32, 0x6c, 0x9e, 0x36,
	0x06, 0x03, 0x89, 0x9b, 0x55, 0x6b, 0x70, 0xa3, 0x3d, 0x1c, 0x7c, 0x5e, 0xff, 0xf4, 0xd3, 0xd3,
	0xc6, 0xf0, 0xb4, 0x79, 0x3c, 0x30, 0x8e, 0x9b, 0xed, 0xe1, 0xf0, 0xd8, 0xa8, 0xe4, 0x54, 0x0d,
	0xaa, 0xed, 0xe1, 0xe0, 0x41, 0x3d, 0x3e, 0xb2, 0xa6, 0xee, 0xc2, 0xb6, 0xbc, 0x3e, 0x95, 0xaa,
	0xac, 0xab, 0x15, 0x28, 0xf2, 0x25, 0x18, 0x67, 0xe3, 0x1e, 0x89, 0x8a, 0xd4, 0xcd, 0xd5, 0x22,
	0xe4, 0x8f, 0x8e, 0x9b, 0x8f, 0x1b, 0x47, 0xdd, 0x76, 0xe5, 0x1d, 0x42, 0x0d, 0xdb, 0xa3, 0xd3,
	0x91, 0x71, 0xd2, 0xae, 0x28, 0x64, 0x8f, 0x84, 0xea, 0x34, 0xfa, 0xc3, 0x76, 0x25, 0x53, 0xff,
	0x6f, 0x11, 0x72, 0xdd, 0xde, 0xa8, 0xae, 0xf6, 0xa0, 0x2c, 0x0e, 0xc0, 0x21, 0x8d, 0xa0, 0x5a,
	0x93, 0xa2, 0x19, 0x3b, 0x42, 0x6b, 0xef, 0xa6, 0x8e, 0x71, 0x57, 0x7f, 0xc5, 0x5e, 0x89, 0x0e,
	0xe9, 0x0d, 0x57, 0x7e, 0x87, 0x0b, 0x2f, 0xfe, 0xb5, 0x55, 0x1d, 0x47, 0x6d, 0xc0, 0x26, 0x53,
	0x40, 0x80, 0xd0, 0xcd, 0x88, 0x86, 0xf0, 0x1e, 0xbf, 0x5a, 0xc5, 0x23, 0xc8, 0x11, 0x1c, 0x17,
	0x59, 0x5f, 0x02, 0x76, 0xab, 0x27, 0x7f, 0x01, 0xf9, 0x2e, 0x83, 0xa7, 0xbe, 0x5a, 0x3c, 0xe0,
	0x3f, 0xa2, 0x3c, 0x73, 0x6d, 0xab, 0xf6, 0x9d, 0x15, 0xd3, 0x28, 0x1a, 0xee, 0x0a, 0x78, 0x4f,
	0xf8, 0xea, 0x7b, 0xb2, 0x9b, 0xe2, 0x77, 0xf0, 0xd5, 0x36, 0xfc, 0x18, 0x8a, 0x32, 0x44, 0x56,
	0x23, 0xa0, 0x31, 0x89, 0x9d, 0x6b, 0x11, 0x3b, 0xd5, 0x47, 0xb0, 0x43, 0x3d, 0x48, 0xca, 0x96,
	0xb6, 0x3f, 0x76, 0x7d, 0x5c, 0x16, 0x8d, 0xe8, 0xe4, 0xcf, 0x60, 0xcb, 0x40, 0x3e, 0x77, 0x00,
	0xb3, 0xe6, 0x7a, 0x13, 0x3f, 0x17, 0xf7, 0xc7, 0x37, 0x9e, 0xf9, 0x04, 0x8a, 0xc2, 0xe3, 0xf4,
	0x86, 0xb7, 0x1c, 0x44, 0x5d, 0x1d, 0x82, 0xaf, 0x60, 0x8b, 0xea, 0x1a, 0x23, 0x87, 0x61, 0x52,
	0x7f, 0xa9, 0x11, 0xd5, 0xf8, 0x2b, 0x31, 0x55, 0xf0, 0x23, 0xda, 0xff, 0xfb, 0x26, 0x46, 0x3e,
	0x53, 0xb0, 0x74, 0x7e, 0xe2, 0x95, 0x59, 0x6d, 0x81, 0xb6, 0x98, 0xcb, 0xd1, 0xe2, 0x59, 0x30,
	0x7d, 0x53, 0x2d, 0x43, 0xa8, 0xc4, 0x11, 0xa2, 0xaa, 0x4b, 0x52, 0x4b, 0xe0, 0xe3, 0x55, 0x55,
	0x55, 0x34, 0x02, 0xa7, 0xef, 0x8e, 0xcd, 0x29, 0xc1, 0x4b, 0x11, 0x73, 0x24, 0xc4, 0x57, 0xbb,
	0x99, 0xe0, 0xb3, 0xba, 0xbe, 0xaf, 0xa8, 0x4f, 0xa0, 0x44, 0x0b, 0x5d, 0x00, 0xa4, 0x48, 0x82,
	0x27, 0x70, 0xd3, 0x6a, 0x73, 0x9e, 0x42, 0xa9, 0x63, 0x3b, 0xd6, 0x35, 0x0a, 0xfd, 0xbb, 0xab,
	0xd0, 0x49, 0xd8, 0x74, 0x36, 0xf8, 0xcb, 0x61, 0x2c, 0x79, 0xe4, 0xd7, 0xc4, 0x55, 0x7b, 0xfb,
	0x12, 0xca, 0x43, 0x84, 0x25, 0x40, 0xa2, 0xbe, 0x2f, 0x09, 0x27, 0x51, 0x4f, 0x2c, 0x83, 0x4d,
	0xa8, 0x12, 0xd0, 0x10, 0x87, 0x1b, 0xaa, 0x6c, 0xfc, 0x32, 0x78, 0x53, 0xbb, 0xb3, 0x5a, 0x68,
	0xb1, 0x45, 0x09, 0x4f, 0x8c, 0x58, 0x71, 0x47, 0x22, 0x90, 0x40, 0x1b, 0x31, 0x1b, 0x3b, 0x50,
	0xe9, 0x22, 0x96, 0xd2, 0xcf, 0x6d, 0x4c, 0x05, 0x23, 0xce, 0x8a, 0xa2, 0x9e, 0x88, 0xb3, 0x22,
	0xa7, 0xfe, 0x21, 0x14, 0x78, 0xb5, 0xbe, 0x75, 0x8f, 0xaf, 0xff, 0x5d, 0x81, 0x72, 0xb7, 0x37,
	0x92, 0x7f, 0x15, 0xfd, 0x29, 0x00, 0x7d, 0x3c, 0xbd, 0x70, 0x5f, 0x22, 0x4b, 0xdd, 0x5b, 0xfe,
	0x5b, 0x2a, 0xd7, 0xff, 0xc1, 0x0a, 0x09, 0x6e, 0x69, 0x1f, 0xaa, 0x69, 0x3f, 0xe2, 0xaa, 0x77,
	0x13, 0x8d, 0x39, 0x7d, 0x89, 0x88, 0xff, 0x0e, 0xfb, 0x70, 0xc7, 0x41, 0x58, 0xfe, 0x01, 0x9d,
	0xff, 0xa4, 0x6e, 0xce, 0x6d, 0x3f, 0xd4, 0xf8, 0xf5, 0x9d, 0xeb, 0xfc, 0xb4, 0xff, 0x62, 0x9d,
	0xfe, 0xd4, 0xfe, 0xe0, 0x7f, 0x01, 0x00, 0x00, 0xff, 0xff, 0xd5, 0xb1, 0x6f, 0x8a, 0x09, 0x20,
	0x00, 0x00,
}
