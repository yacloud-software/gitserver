// Code generated by protoc-gen-go.
// source: protos/golang.conradwood.net/apis/gitserver/gitserver.proto
// DO NOT EDIT!

/*
Package gitserver is a generated protocol buffer package.

It is generated from these files:
	protos/golang.conradwood.net/apis/gitserver/gitserver.proto

It has these top-level messages:
	GitCredentials
	RepoTagRequest
	CreateRepoLog
	Build
	BuildList
	RepositoryList
	Permission
	Watchers
	Repository
	GroupRepositoryAccess
	UserRepositoryAccess
	PostReceiveRequest
	PostReceiveStream
	ByIDRequest
	ByURLRequest
	RepositoryInfo
	GitInfo
	CreateRepoRequest
	SourceRepository
	SourceRepositoryURL
	SourceRepositoryList
	SetRepoFlagsRequest
	ForkRequest
	PingState
	CheckGitRequest
	CheckGitResponse
	RepoFilter
	UpdateRepoStatusRequest
	GitCredentialsRequest
	GitCredentialsResponse
*/
package gitserver

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import common "golang.conradwood.net/apis/common"
import auth "golang.conradwood.net/apis/auth"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type REPOTAG int32

const (
	REPOTAG_UNDEFINED    REPOTAG = 0
	REPOTAG_FIRMWARE     REPOTAG = 1
	REPOTAG_LOADER       REPOTAG = 2
	REPOTAG_FIRMWARE_APP REPOTAG = 3
)

var REPOTAG_name = map[int32]string{
	0: "UNDEFINED",
	1: "FIRMWARE",
	2: "LOADER",
	3: "FIRMWARE_APP",
}
var REPOTAG_value = map[string]int32{
	"UNDEFINED":    0,
	"FIRMWARE":     1,
	"LOADER":       2,
	"FIRMWARE_APP": 3,
}

func (x REPOTAG) String() string {
	return proto.EnumName(REPOTAG_name, int32(x))
}
func (REPOTAG) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type NewRepoState int32

const (
	NewRepoState_NOCHANGE  NewRepoState = 0
	NewRepoState_SET_TRUE  NewRepoState = 1
	NewRepoState_SET_FALSE NewRepoState = 2
)

var NewRepoState_name = map[int32]string{
	0: "NOCHANGE",
	1: "SET_TRUE",
	2: "SET_FALSE",
}
var NewRepoState_value = map[string]int32{
	"NOCHANGE":  0,
	"SET_TRUE":  1,
	"SET_FALSE": 2,
}

func (x NewRepoState) String() string {
	return proto.EnumName(NewRepoState_name, int32(x))
}
func (NewRepoState) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

type GitCredentials struct {
	ID       uint64 `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	UserID   string `protobuf:"bytes,2,opt,name=UserID" json:"UserID,omitempty"`
	Host     string `protobuf:"bytes,3,opt,name=Host" json:"Host,omitempty"`
	Path     string `protobuf:"bytes,4,opt,name=Path" json:"Path,omitempty"`
	Username string `protobuf:"bytes,5,opt,name=Username" json:"Username,omitempty"`
	Password string `protobuf:"bytes,6,opt,name=Password" json:"Password,omitempty"`
}

func (m *GitCredentials) Reset()                    { *m = GitCredentials{} }
func (m *GitCredentials) String() string            { return proto.CompactTextString(m) }
func (*GitCredentials) ProtoMessage()               {}
func (*GitCredentials) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *GitCredentials) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *GitCredentials) GetUserID() string {
	if m != nil {
		return m.UserID
	}
	return ""
}

func (m *GitCredentials) GetHost() string {
	if m != nil {
		return m.Host
	}
	return ""
}

func (m *GitCredentials) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *GitCredentials) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *GitCredentials) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

type RepoTagRequest struct {
	Tag uint32 `protobuf:"varint,1,opt,name=Tag" json:"Tag,omitempty"`
}

func (m *RepoTagRequest) Reset()                    { *m = RepoTagRequest{} }
func (m *RepoTagRequest) String() string            { return proto.CompactTextString(m) }
func (*RepoTagRequest) ProtoMessage()               {}
func (*RepoTagRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *RepoTagRequest) GetTag() uint32 {
	if m != nil {
		return m.Tag
	}
	return 0
}

// a log and statemachine in the database for creating repos
type CreateRepoLog struct {
	// database id
	ID uint64 `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	// which repo does it refer to?
	RepositoryID uint64 `protobuf:"varint,2,opt,name=RepositoryID" json:"RepositoryID,omitempty"`
	// user who runs this (also in context)
	UserID string `protobuf:"bytes,3,opt,name=UserID" json:"UserID,omitempty"`
	// serialised context
	Context string `protobuf:"bytes,4,opt,name=Context" json:"Context,omitempty"`
	// defines what this 'logentry' does/did. See gitserver source for specifics
	Action uint32 `protobuf:"varint,5,opt,name=Action" json:"Action,omitempty"`
	// true if this succeeded
	Success bool `protobuf:"varint,6,opt,name=Success" json:"Success,omitempty"`
	// if !success, here's the error message
	ErrorMessage     string `protobuf:"bytes,7,opt,name=ErrorMessage" json:"ErrorMessage,omitempty"`
	Started          uint32 `protobuf:"varint,8,opt,name=Started" json:"Started,omitempty"`
	Finished         uint32 `protobuf:"varint,9,opt,name=Finished" json:"Finished,omitempty"`
	AssociationToken string `protobuf:"bytes,10,opt,name=AssociationToken" json:"AssociationToken,omitempty"`
}

func (m *CreateRepoLog) Reset()                    { *m = CreateRepoLog{} }
func (m *CreateRepoLog) String() string            { return proto.CompactTextString(m) }
func (*CreateRepoLog) ProtoMessage()               {}
func (*CreateRepoLog) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *CreateRepoLog) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *CreateRepoLog) GetRepositoryID() uint64 {
	if m != nil {
		return m.RepositoryID
	}
	return 0
}

func (m *CreateRepoLog) GetUserID() string {
	if m != nil {
		return m.UserID
	}
	return ""
}

func (m *CreateRepoLog) GetContext() string {
	if m != nil {
		return m.Context
	}
	return ""
}

func (m *CreateRepoLog) GetAction() uint32 {
	if m != nil {
		return m.Action
	}
	return 0
}

func (m *CreateRepoLog) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

func (m *CreateRepoLog) GetErrorMessage() string {
	if m != nil {
		return m.ErrorMessage
	}
	return ""
}

func (m *CreateRepoLog) GetStarted() uint32 {
	if m != nil {
		return m.Started
	}
	return 0
}

func (m *CreateRepoLog) GetFinished() uint32 {
	if m != nil {
		return m.Finished
	}
	return 0
}

func (m *CreateRepoLog) GetAssociationToken() string {
	if m != nil {
		return m.AssociationToken
	}
	return ""
}

type Build struct {
	ID           uint64 `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	RepositoryID uint64 `protobuf:"varint,2,opt,name=RepositoryID" json:"RepositoryID,omitempty"`
	CommitHash   string `protobuf:"bytes,3,opt,name=CommitHash" json:"CommitHash,omitempty"`
	Branch       string `protobuf:"bytes,4,opt,name=Branch" json:"Branch,omitempty"`
	LogMessage   string `protobuf:"bytes,5,opt,name=LogMessage" json:"LogMessage,omitempty"`
	UserID       string `protobuf:"bytes,6,opt,name=UserID" json:"UserID,omitempty"`
	Timestamp    uint32 `protobuf:"varint,7,opt,name=Timestamp" json:"Timestamp,omitempty"`
	Success      bool   `protobuf:"varint,8,opt,name=Success" json:"Success,omitempty"`
}

func (m *Build) Reset()                    { *m = Build{} }
func (m *Build) String() string            { return proto.CompactTextString(m) }
func (*Build) ProtoMessage()               {}
func (*Build) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *Build) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Build) GetRepositoryID() uint64 {
	if m != nil {
		return m.RepositoryID
	}
	return 0
}

func (m *Build) GetCommitHash() string {
	if m != nil {
		return m.CommitHash
	}
	return ""
}

func (m *Build) GetBranch() string {
	if m != nil {
		return m.Branch
	}
	return ""
}

func (m *Build) GetLogMessage() string {
	if m != nil {
		return m.LogMessage
	}
	return ""
}

func (m *Build) GetUserID() string {
	if m != nil {
		return m.UserID
	}
	return ""
}

func (m *Build) GetTimestamp() uint32 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *Build) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

type BuildList struct {
	Builds []*Build `protobuf:"bytes,1,rep,name=Builds" json:"Builds,omitempty"`
}

func (m *BuildList) Reset()                    { *m = BuildList{} }
func (m *BuildList) String() string            { return proto.CompactTextString(m) }
func (*BuildList) ProtoMessage()               {}
func (*BuildList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *BuildList) GetBuilds() []*Build {
	if m != nil {
		return m.Builds
	}
	return nil
}

type RepositoryList struct {
	Repos []*Repository `protobuf:"bytes,1,rep,name=Repos" json:"Repos,omitempty"`
}

func (m *RepositoryList) Reset()                    { *m = RepositoryList{} }
func (m *RepositoryList) String() string            { return proto.CompactTextString(m) }
func (*RepositoryList) ProtoMessage()               {}
func (*RepositoryList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *RepositoryList) GetRepos() []*Repository {
	if m != nil {
		return m.Repos
	}
	return nil
}

type Permission struct {
	Read    bool `protobuf:"varint,1,opt,name=Read" json:"Read,omitempty"`
	Write   bool `protobuf:"varint,2,opt,name=Write" json:"Write,omitempty"`
	Execute bool `protobuf:"varint,3,opt,name=Execute" json:"Execute,omitempty"`
	List    bool `protobuf:"varint,4,opt,name=List" json:"List,omitempty"`
}

func (m *Permission) Reset()                    { *m = Permission{} }
func (m *Permission) String() string            { return proto.CompactTextString(m) }
func (*Permission) ProtoMessage()               {}
func (*Permission) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *Permission) GetRead() bool {
	if m != nil {
		return m.Read
	}
	return false
}

func (m *Permission) GetWrite() bool {
	if m != nil {
		return m.Write
	}
	return false
}

func (m *Permission) GetExecute() bool {
	if m != nil {
		return m.Execute
	}
	return false
}

func (m *Permission) GetList() bool {
	if m != nil {
		return m.List
	}
	return false
}

//
// A "watcher" is someone who watches pushes to a given repository.
// Note that pushes by "oneself" will not be notified.
// Otherwise each push will be send via slack
type Watchers struct {
	ID           uint64 `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	UserID       string `protobuf:"bytes,2,opt,name=UserID" json:"UserID,omitempty"`
	RepositoryID uint64 `protobuf:"varint,3,opt,name=RepositoryID" json:"RepositoryID,omitempty"`
	Notifytype   uint32 `protobuf:"varint,4,opt,name=Notifytype" json:"Notifytype,omitempty"`
}

func (m *Watchers) Reset()                    { *m = Watchers{} }
func (m *Watchers) String() string            { return proto.CompactTextString(m) }
func (*Watchers) ProtoMessage()               {}
func (*Watchers) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *Watchers) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Watchers) GetUserID() string {
	if m != nil {
		return m.UserID
	}
	return ""
}

func (m *Watchers) GetRepositoryID() uint64 {
	if m != nil {
		return m.RepositoryID
	}
	return 0
}

func (m *Watchers) GetNotifytype() uint32 {
	if m != nil {
		return m.Notifytype
	}
	return 0
}

type Repository struct {
	ID           uint64      `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	RepoName     string      `protobuf:"bytes,2,opt,name=RepoName" json:"RepoName,omitempty"`
	OwnerID      string      `protobuf:"bytes,3,opt,name=OwnerID" json:"OwnerID,omitempty"`
	ArtefactName string      `protobuf:"bytes,4,opt,name=ArtefactName" json:"ArtefactName,omitempty"`
	Permission   *Permission `protobuf:"bytes,5,opt,name=Permission" json:"Permission,omitempty"`
}

func (m *Repository) Reset()                    { *m = Repository{} }
func (m *Repository) String() string            { return proto.CompactTextString(m) }
func (*Repository) ProtoMessage()               {}
func (*Repository) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *Repository) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Repository) GetRepoName() string {
	if m != nil {
		return m.RepoName
	}
	return ""
}

func (m *Repository) GetOwnerID() string {
	if m != nil {
		return m.OwnerID
	}
	return ""
}

func (m *Repository) GetArtefactName() string {
	if m != nil {
		return m.ArtefactName
	}
	return ""
}

func (m *Repository) GetPermission() *Permission {
	if m != nil {
		return m.Permission
	}
	return nil
}

type GroupRepositoryAccess struct {
	ID      uint64 `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	RepoID  uint64 `protobuf:"varint,2,opt,name=RepoID" json:"RepoID,omitempty"`
	GroupID string `protobuf:"bytes,3,opt,name=GroupID" json:"GroupID,omitempty"`
	Read    bool   `protobuf:"varint,4,opt,name=Read" json:"Read,omitempty"`
	Write   bool   `protobuf:"varint,5,opt,name=Write" json:"Write,omitempty"`
}

func (m *GroupRepositoryAccess) Reset()                    { *m = GroupRepositoryAccess{} }
func (m *GroupRepositoryAccess) String() string            { return proto.CompactTextString(m) }
func (*GroupRepositoryAccess) ProtoMessage()               {}
func (*GroupRepositoryAccess) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *GroupRepositoryAccess) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *GroupRepositoryAccess) GetRepoID() uint64 {
	if m != nil {
		return m.RepoID
	}
	return 0
}

func (m *GroupRepositoryAccess) GetGroupID() string {
	if m != nil {
		return m.GroupID
	}
	return ""
}

func (m *GroupRepositoryAccess) GetRead() bool {
	if m != nil {
		return m.Read
	}
	return false
}

func (m *GroupRepositoryAccess) GetWrite() bool {
	if m != nil {
		return m.Write
	}
	return false
}

type UserRepositoryAccess struct {
	ID     uint64 `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	RepoID uint64 `protobuf:"varint,2,opt,name=RepoID" json:"RepoID,omitempty"`
	UserID string `protobuf:"bytes,3,opt,name=UserID" json:"UserID,omitempty"`
	Read   bool   `protobuf:"varint,4,opt,name=Read" json:"Read,omitempty"`
	Write  bool   `protobuf:"varint,5,opt,name=Write" json:"Write,omitempty"`
}

func (m *UserRepositoryAccess) Reset()                    { *m = UserRepositoryAccess{} }
func (m *UserRepositoryAccess) String() string            { return proto.CompactTextString(m) }
func (*UserRepositoryAccess) ProtoMessage()               {}
func (*UserRepositoryAccess) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *UserRepositoryAccess) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *UserRepositoryAccess) GetRepoID() uint64 {
	if m != nil {
		return m.RepoID
	}
	return 0
}

func (m *UserRepositoryAccess) GetUserID() string {
	if m != nil {
		return m.UserID
	}
	return ""
}

func (m *UserRepositoryAccess) GetRead() bool {
	if m != nil {
		return m.Read
	}
	return false
}

func (m *UserRepositoryAccess) GetWrite() bool {
	if m != nil {
		return m.Write
	}
	return false
}

type PostReceiveRequest struct {
	RepoDirectory string `protobuf:"bytes,1,opt,name=RepoDirectory" json:"RepoDirectory,omitempty"`
	Ref           string `protobuf:"bytes,2,opt,name=Ref" json:"Ref,omitempty"`
	OldRevision   string `protobuf:"bytes,3,opt,name=OldRevision" json:"OldRevision,omitempty"`
	NewRevision   string `protobuf:"bytes,4,opt,name=NewRevision" json:"NewRevision,omitempty"`
}

func (m *PostReceiveRequest) Reset()                    { *m = PostReceiveRequest{} }
func (m *PostReceiveRequest) String() string            { return proto.CompactTextString(m) }
func (*PostReceiveRequest) ProtoMessage()               {}
func (*PostReceiveRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *PostReceiveRequest) GetRepoDirectory() string {
	if m != nil {
		return m.RepoDirectory
	}
	return ""
}

func (m *PostReceiveRequest) GetRef() string {
	if m != nil {
		return m.Ref
	}
	return ""
}

func (m *PostReceiveRequest) GetOldRevision() string {
	if m != nil {
		return m.OldRevision
	}
	return ""
}

func (m *PostReceiveRequest) GetNewRevision() string {
	if m != nil {
		return m.NewRevision
	}
	return ""
}

type PostReceiveStream struct {
}

func (m *PostReceiveStream) Reset()                    { *m = PostReceiveStream{} }
func (m *PostReceiveStream) String() string            { return proto.CompactTextString(m) }
func (*PostReceiveStream) ProtoMessage()               {}
func (*PostReceiveStream) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

type ByIDRequest struct {
	ID uint64 `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
}

func (m *ByIDRequest) Reset()                    { *m = ByIDRequest{} }
func (m *ByIDRequest) String() string            { return proto.CompactTextString(m) }
func (*ByIDRequest) ProtoMessage()               {}
func (*ByIDRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *ByIDRequest) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

type ByURLRequest struct {
	URL string `protobuf:"bytes,1,opt,name=URL" json:"URL,omitempty"`
}

func (m *ByURLRequest) Reset()                    { *m = ByURLRequest{} }
func (m *ByURLRequest) String() string            { return proto.CompactTextString(m) }
func (*ByURLRequest) ProtoMessage()               {}
func (*ByURLRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *ByURLRequest) GetURL() string {
	if m != nil {
		return m.URL
	}
	return ""
}

type RepositoryInfo struct {
	Repository *Repository `protobuf:"bytes,1,opt,name=Repository" json:"Repository,omitempty"`
}

func (m *RepositoryInfo) Reset()                    { *m = RepositoryInfo{} }
func (m *RepositoryInfo) String() string            { return proto.CompactTextString(m) }
func (*RepositoryInfo) ProtoMessage()               {}
func (*RepositoryInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *RepositoryInfo) GetRepository() *Repository {
	if m != nil {
		return m.Repository
	}
	return nil
}

// this message is passed through the CGI as environment variable back to the builder
type GitInfo struct {
	RepositoryID uint64     `protobuf:"varint,1,opt,name=RepositoryID" json:"RepositoryID,omitempty"`
	UserID       string     `protobuf:"bytes,2,opt,name=UserID" json:"UserID,omitempty"`
	User         *auth.User `protobuf:"bytes,3,opt,name=User" json:"User,omitempty"`
	Version      uint32     `protobuf:"varint,4,opt,name=Version" json:"Version,omitempty"`
	URL          string     `protobuf:"bytes,5,opt,name=URL" json:"URL,omitempty"`
}

func (m *GitInfo) Reset()                    { *m = GitInfo{} }
func (m *GitInfo) String() string            { return proto.CompactTextString(m) }
func (*GitInfo) ProtoMessage()               {}
func (*GitInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *GitInfo) GetRepositoryID() uint64 {
	if m != nil {
		return m.RepositoryID
	}
	return 0
}

func (m *GitInfo) GetUserID() string {
	if m != nil {
		return m.UserID
	}
	return ""
}

func (m *GitInfo) GetUser() *auth.User {
	if m != nil {
		return m.User
	}
	return nil
}

func (m *GitInfo) GetVersion() uint32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *GitInfo) GetURL() string {
	if m != nil {
		return m.URL
	}
	return ""
}

type CreateRepoRequest struct {
	ArtefactName string               `protobuf:"bytes,1,opt,name=ArtefactName" json:"ArtefactName,omitempty"`
	URL          *SourceRepositoryURL `protobuf:"bytes,2,opt,name=URL" json:"URL,omitempty"`
	Description  string               `protobuf:"bytes,3,opt,name=Description" json:"Description,omitempty"`
}

func (m *CreateRepoRequest) Reset()                    { *m = CreateRepoRequest{} }
func (m *CreateRepoRequest) String() string            { return proto.CompactTextString(m) }
func (*CreateRepoRequest) ProtoMessage()               {}
func (*CreateRepoRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

func (m *CreateRepoRequest) GetArtefactName() string {
	if m != nil {
		return m.ArtefactName
	}
	return ""
}

func (m *CreateRepoRequest) GetURL() *SourceRepositoryURL {
	if m != nil {
		return m.URL
	}
	return nil
}

func (m *CreateRepoRequest) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

// stored in database. Maps a URL to a filepath and a unique ID
type SourceRepository struct {
	ID           uint64                 `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	FilePath     string                 `protobuf:"bytes,2,opt,name=FilePath" json:"FilePath,omitempty"`
	URLs         []*SourceRepositoryURL `protobuf:"bytes,3,rep,name=URLs" json:"URLs,omitempty"`
	ArtefactName string                 `protobuf:"bytes,4,opt,name=ArtefactName" json:"ArtefactName,omitempty"`
	// if true: run the post-receive hook
	RunPostReceive bool `protobuf:"varint,5,opt,name=RunPostReceive" json:"RunPostReceive,omitempty"`
	// if true: run the pre-receive hook
	RunPreReceive        bool   `protobuf:"varint,6,opt,name=RunPreReceive" json:"RunPreReceive,omitempty"`
	CreatedComplete      bool   `protobuf:"varint,7,opt,name=CreatedComplete" json:"CreatedComplete,omitempty"`
	Description          string `protobuf:"bytes,8,opt,name=Description" json:"Description,omitempty"`
	UserCommits          uint64 `protobuf:"varint,9,opt,name=UserCommits" json:"UserCommits,omitempty"`
	Deleted              bool   `protobuf:"varint,10,opt,name=Deleted" json:"Deleted,omitempty"`
	DeletedTimestamp     uint32 `protobuf:"varint,11,opt,name=DeletedTimestamp" json:"DeletedTimestamp,omitempty"`
	DeleteUser           string `protobuf:"bytes,12,opt,name=DeleteUser" json:"DeleteUser,omitempty"`
	LastCommit           uint32 `protobuf:"varint,13,opt,name=LastCommit" json:"LastCommit,omitempty"`
	LastCommitUser       string `protobuf:"bytes,14,opt,name=LastCommitUser" json:"LastCommitUser,omitempty"`
	Tags                 uint32 `protobuf:"varint,15,opt,name=Tags" json:"Tags,omitempty"`
	Forking              bool   `protobuf:"varint,16,opt,name=Forking" json:"Forking,omitempty"`
	ForkedFrom           uint64 `protobuf:"varint,17,opt,name=ForkedFrom" json:"ForkedFrom,omitempty"`
	BuildRoutingTagName  string `protobuf:"bytes,18,opt,name=BuildRoutingTagName" json:"BuildRoutingTagName,omitempty"`
	BuildRoutingTagValue string `protobuf:"bytes,19,opt,name=BuildRoutingTagValue" json:"BuildRoutingTagValue,omitempty"`
	ReadOnly             bool   `protobuf:"varint,20,opt,name=ReadOnly" json:"ReadOnly,omitempty"`
	CreateUser           string `protobuf:"bytes,21,opt,name=CreateUser" json:"CreateUser,omitempty"`
}

func (m *SourceRepository) Reset()                    { *m = SourceRepository{} }
func (m *SourceRepository) String() string            { return proto.CompactTextString(m) }
func (*SourceRepository) ProtoMessage()               {}
func (*SourceRepository) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

func (m *SourceRepository) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *SourceRepository) GetFilePath() string {
	if m != nil {
		return m.FilePath
	}
	return ""
}

func (m *SourceRepository) GetURLs() []*SourceRepositoryURL {
	if m != nil {
		return m.URLs
	}
	return nil
}

func (m *SourceRepository) GetArtefactName() string {
	if m != nil {
		return m.ArtefactName
	}
	return ""
}

func (m *SourceRepository) GetRunPostReceive() bool {
	if m != nil {
		return m.RunPostReceive
	}
	return false
}

func (m *SourceRepository) GetRunPreReceive() bool {
	if m != nil {
		return m.RunPreReceive
	}
	return false
}

func (m *SourceRepository) GetCreatedComplete() bool {
	if m != nil {
		return m.CreatedComplete
	}
	return false
}

func (m *SourceRepository) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *SourceRepository) GetUserCommits() uint64 {
	if m != nil {
		return m.UserCommits
	}
	return 0
}

func (m *SourceRepository) GetDeleted() bool {
	if m != nil {
		return m.Deleted
	}
	return false
}

func (m *SourceRepository) GetDeletedTimestamp() uint32 {
	if m != nil {
		return m.DeletedTimestamp
	}
	return 0
}

func (m *SourceRepository) GetDeleteUser() string {
	if m != nil {
		return m.DeleteUser
	}
	return ""
}

func (m *SourceRepository) GetLastCommit() uint32 {
	if m != nil {
		return m.LastCommit
	}
	return 0
}

func (m *SourceRepository) GetLastCommitUser() string {
	if m != nil {
		return m.LastCommitUser
	}
	return ""
}

func (m *SourceRepository) GetTags() uint32 {
	if m != nil {
		return m.Tags
	}
	return 0
}

func (m *SourceRepository) GetForking() bool {
	if m != nil {
		return m.Forking
	}
	return false
}

func (m *SourceRepository) GetForkedFrom() uint64 {
	if m != nil {
		return m.ForkedFrom
	}
	return 0
}

func (m *SourceRepository) GetBuildRoutingTagName() string {
	if m != nil {
		return m.BuildRoutingTagName
	}
	return ""
}

func (m *SourceRepository) GetBuildRoutingTagValue() string {
	if m != nil {
		return m.BuildRoutingTagValue
	}
	return ""
}

func (m *SourceRepository) GetReadOnly() bool {
	if m != nil {
		return m.ReadOnly
	}
	return false
}

func (m *SourceRepository) GetCreateUser() string {
	if m != nil {
		return m.CreateUser
	}
	return ""
}

// the URL a given repository can be accessed under.
// Note: Repositories may be accessed under multiple different URLs
type SourceRepositoryURL struct {
	ID uint64 `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	// the Repository we're referring to on disk
	V2RepositoryID uint64 `protobuf:"varint,2,opt,name=V2RepositoryID" json:"V2RepositoryID,omitempty"`
	// which Host do we expose this on, e.g. "git.singingcat.net"
	Host string `protobuf:"bytes,3,opt,name=Host" json:"Host,omitempty"`
	// which path do we expose this on, e.g. "/git/foobar.git"
	Path string `protobuf:"bytes,4,opt,name=Path" json:"Path,omitempty"`
}

func (m *SourceRepositoryURL) Reset()                    { *m = SourceRepositoryURL{} }
func (m *SourceRepositoryURL) String() string            { return proto.CompactTextString(m) }
func (*SourceRepositoryURL) ProtoMessage()               {}
func (*SourceRepositoryURL) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{19} }

func (m *SourceRepositoryURL) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *SourceRepositoryURL) GetV2RepositoryID() uint64 {
	if m != nil {
		return m.V2RepositoryID
	}
	return 0
}

func (m *SourceRepositoryURL) GetHost() string {
	if m != nil {
		return m.Host
	}
	return ""
}

func (m *SourceRepositoryURL) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

type SourceRepositoryList struct {
	Repos []*SourceRepository `protobuf:"bytes,1,rep,name=Repos" json:"Repos,omitempty"`
}

func (m *SourceRepositoryList) Reset()                    { *m = SourceRepositoryList{} }
func (m *SourceRepositoryList) String() string            { return proto.CompactTextString(m) }
func (*SourceRepositoryList) ProtoMessage()               {}
func (*SourceRepositoryList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{20} }

func (m *SourceRepositoryList) GetRepos() []*SourceRepository {
	if m != nil {
		return m.Repos
	}
	return nil
}

//
// service OLDGIT {
// // deprecated and obsolete: get a repo by ID
// rpc RepoByID(ByIDRequest) returns (RepositoryInfo);
// // deprecated and obsolete: called by git post receive hook
// rpc PostReceive(PostReceiveRequest) returns (stream PostReceiveStream);
// //  deprecated and obsolete: get all repos we got access to
// rpc GetRepos(common.Void) returns (RepositoryList);
// //  deprecated and obsolete: we sometimes hit it badly...
// rpc GetCPULoad(common.Void) returns (common.CPULoad);
// //  deprecated and obsolete: fork a repo, returns ID of new repo
// rpc Fork(ByIDRequest) returns (Repository);
// }
type SetRepoFlagsRequest struct {
	RepoID         uint64 `protobuf:"varint,1,opt,name=RepoID" json:"RepoID,omitempty"`
	RunPostReceive bool   `protobuf:"varint,2,opt,name=RunPostReceive" json:"RunPostReceive,omitempty"`
	RunPreReceive  bool   `protobuf:"varint,3,opt,name=RunPreReceive" json:"RunPreReceive,omitempty"`
	ReadOnly       bool   `protobuf:"varint,4,opt,name=ReadOnly" json:"ReadOnly,omitempty"`
}

func (m *SetRepoFlagsRequest) Reset()                    { *m = SetRepoFlagsRequest{} }
func (m *SetRepoFlagsRequest) String() string            { return proto.CompactTextString(m) }
func (*SetRepoFlagsRequest) ProtoMessage()               {}
func (*SetRepoFlagsRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{21} }

func (m *SetRepoFlagsRequest) GetRepoID() uint64 {
	if m != nil {
		return m.RepoID
	}
	return 0
}

func (m *SetRepoFlagsRequest) GetRunPostReceive() bool {
	if m != nil {
		return m.RunPostReceive
	}
	return false
}

func (m *SetRepoFlagsRequest) GetRunPreReceive() bool {
	if m != nil {
		return m.RunPreReceive
	}
	return false
}

func (m *SetRepoFlagsRequest) GetReadOnly() bool {
	if m != nil {
		return m.ReadOnly
	}
	return false
}

type ForkRequest struct {
	RepositoryID   uint64               `protobuf:"varint,1,opt,name=RepositoryID" json:"RepositoryID,omitempty"`
	ArtefactName   string               `protobuf:"bytes,2,opt,name=ArtefactName" json:"ArtefactName,omitempty"`
	URL            *SourceRepositoryURL `protobuf:"bytes,3,opt,name=URL" json:"URL,omitempty"`
	Description    string               `protobuf:"bytes,4,opt,name=Description" json:"Description,omitempty"`
	CreateReadOnly bool                 `protobuf:"varint,5,opt,name=CreateReadOnly" json:"CreateReadOnly,omitempty"`
}

func (m *ForkRequest) Reset()                    { *m = ForkRequest{} }
func (m *ForkRequest) String() string            { return proto.CompactTextString(m) }
func (*ForkRequest) ProtoMessage()               {}
func (*ForkRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{22} }

func (m *ForkRequest) GetRepositoryID() uint64 {
	if m != nil {
		return m.RepositoryID
	}
	return 0
}

func (m *ForkRequest) GetArtefactName() string {
	if m != nil {
		return m.ArtefactName
	}
	return ""
}

func (m *ForkRequest) GetURL() *SourceRepositoryURL {
	if m != nil {
		return m.URL
	}
	return nil
}

func (m *ForkRequest) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *ForkRequest) GetCreateReadOnly() bool {
	if m != nil {
		return m.CreateReadOnly
	}
	return false
}

type PingState struct {
	ID               uint64 `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	AssociationToken string `protobuf:"bytes,2,opt,name=AssociationToken" json:"AssociationToken,omitempty"`
	Created          uint32 `protobuf:"varint,3,opt,name=Created" json:"Created,omitempty"`
	ResponseToken    string `protobuf:"bytes,4,opt,name=ResponseToken" json:"ResponseToken,omitempty"`
}

func (m *PingState) Reset()                    { *m = PingState{} }
func (m *PingState) String() string            { return proto.CompactTextString(m) }
func (*PingState) ProtoMessage()               {}
func (*PingState) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{23} }

func (m *PingState) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *PingState) GetAssociationToken() string {
	if m != nil {
		return m.AssociationToken
	}
	return ""
}

func (m *PingState) GetCreated() uint32 {
	if m != nil {
		return m.Created
	}
	return 0
}

func (m *PingState) GetResponseToken() string {
	if m != nil {
		return m.ResponseToken
	}
	return ""
}

type CheckGitRequest struct {
	Host string `protobuf:"bytes,1,opt,name=Host" json:"Host,omitempty"`
}

func (m *CheckGitRequest) Reset()                    { *m = CheckGitRequest{} }
func (m *CheckGitRequest) String() string            { return proto.CompactTextString(m) }
func (*CheckGitRequest) ProtoMessage()               {}
func (*CheckGitRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{24} }

func (m *CheckGitRequest) GetHost() string {
	if m != nil {
		return m.Host
	}
	return ""
}

type CheckGitResponse struct {
	Success bool `protobuf:"varint,1,opt,name=Success" json:"Success,omitempty"`
}

func (m *CheckGitResponse) Reset()                    { *m = CheckGitResponse{} }
func (m *CheckGitResponse) String() string            { return proto.CompactTextString(m) }
func (*CheckGitResponse) ProtoMessage()               {}
func (*CheckGitResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{25} }

func (m *CheckGitResponse) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

type RepoFilter struct {
	Tags *RepoTagRequest `protobuf:"bytes,1,opt,name=Tags" json:"Tags,omitempty"`
}

func (m *RepoFilter) Reset()                    { *m = RepoFilter{} }
func (m *RepoFilter) String() string            { return proto.CompactTextString(m) }
func (*RepoFilter) ProtoMessage()               {}
func (*RepoFilter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{26} }

func (m *RepoFilter) GetTags() *RepoTagRequest {
	if m != nil {
		return m.Tags
	}
	return nil
}

type UpdateRepoStatusRequest struct {
	RepoID   uint64       `protobuf:"varint,1,opt,name=RepoID" json:"RepoID,omitempty"`
	ReadOnly NewRepoState `protobuf:"varint,2,opt,name=ReadOnly,enum=gitserver.NewRepoState" json:"ReadOnly,omitempty"`
	RunHooks NewRepoState `protobuf:"varint,3,opt,name=RunHooks,enum=gitserver.NewRepoState" json:"RunHooks,omitempty"`
}

func (m *UpdateRepoStatusRequest) Reset()                    { *m = UpdateRepoStatusRequest{} }
func (m *UpdateRepoStatusRequest) String() string            { return proto.CompactTextString(m) }
func (*UpdateRepoStatusRequest) ProtoMessage()               {}
func (*UpdateRepoStatusRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{27} }

func (m *UpdateRepoStatusRequest) GetRepoID() uint64 {
	if m != nil {
		return m.RepoID
	}
	return 0
}

func (m *UpdateRepoStatusRequest) GetReadOnly() NewRepoState {
	if m != nil {
		return m.ReadOnly
	}
	return NewRepoState_NOCHANGE
}

func (m *UpdateRepoStatusRequest) GetRunHooks() NewRepoState {
	if m != nil {
		return m.RunHooks
	}
	return NewRepoState_NOCHANGE
}

type GitCredentialsRequest struct {
	Args        []string `protobuf:"bytes,1,rep,name=Args" json:"Args,omitempty"`
	Environment []string `protobuf:"bytes,2,rep,name=Environment" json:"Environment,omitempty"`
	Stdin       string   `protobuf:"bytes,3,opt,name=Stdin" json:"Stdin,omitempty"`
}

func (m *GitCredentialsRequest) Reset()                    { *m = GitCredentialsRequest{} }
func (m *GitCredentialsRequest) String() string            { return proto.CompactTextString(m) }
func (*GitCredentialsRequest) ProtoMessage()               {}
func (*GitCredentialsRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{28} }

func (m *GitCredentialsRequest) GetArgs() []string {
	if m != nil {
		return m.Args
	}
	return nil
}

func (m *GitCredentialsRequest) GetEnvironment() []string {
	if m != nil {
		return m.Environment
	}
	return nil
}

func (m *GitCredentialsRequest) GetStdin() string {
	if m != nil {
		return m.Stdin
	}
	return ""
}

type GitCredentialsResponse struct {
	Stdout string `protobuf:"bytes,1,opt,name=Stdout" json:"Stdout,omitempty"`
}

func (m *GitCredentialsResponse) Reset()                    { *m = GitCredentialsResponse{} }
func (m *GitCredentialsResponse) String() string            { return proto.CompactTextString(m) }
func (*GitCredentialsResponse) ProtoMessage()               {}
func (*GitCredentialsResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{29} }

func (m *GitCredentialsResponse) GetStdout() string {
	if m != nil {
		return m.Stdout
	}
	return ""
}

func init() {
	proto.RegisterType((*GitCredentials)(nil), "gitserver.GitCredentials")
	proto.RegisterType((*RepoTagRequest)(nil), "gitserver.RepoTagRequest")
	proto.RegisterType((*CreateRepoLog)(nil), "gitserver.CreateRepoLog")
	proto.RegisterType((*Build)(nil), "gitserver.Build")
	proto.RegisterType((*BuildList)(nil), "gitserver.BuildList")
	proto.RegisterType((*RepositoryList)(nil), "gitserver.RepositoryList")
	proto.RegisterType((*Permission)(nil), "gitserver.Permission")
	proto.RegisterType((*Watchers)(nil), "gitserver.Watchers")
	proto.RegisterType((*Repository)(nil), "gitserver.Repository")
	proto.RegisterType((*GroupRepositoryAccess)(nil), "gitserver.GroupRepositoryAccess")
	proto.RegisterType((*UserRepositoryAccess)(nil), "gitserver.UserRepositoryAccess")
	proto.RegisterType((*PostReceiveRequest)(nil), "gitserver.PostReceiveRequest")
	proto.RegisterType((*PostReceiveStream)(nil), "gitserver.PostReceiveStream")
	proto.RegisterType((*ByIDRequest)(nil), "gitserver.ByIDRequest")
	proto.RegisterType((*ByURLRequest)(nil), "gitserver.ByURLRequest")
	proto.RegisterType((*RepositoryInfo)(nil), "gitserver.RepositoryInfo")
	proto.RegisterType((*GitInfo)(nil), "gitserver.GitInfo")
	proto.RegisterType((*CreateRepoRequest)(nil), "gitserver.CreateRepoRequest")
	proto.RegisterType((*SourceRepository)(nil), "gitserver.SourceRepository")
	proto.RegisterType((*SourceRepositoryURL)(nil), "gitserver.SourceRepositoryURL")
	proto.RegisterType((*SourceRepositoryList)(nil), "gitserver.SourceRepositoryList")
	proto.RegisterType((*SetRepoFlagsRequest)(nil), "gitserver.SetRepoFlagsRequest")
	proto.RegisterType((*ForkRequest)(nil), "gitserver.ForkRequest")
	proto.RegisterType((*PingState)(nil), "gitserver.PingState")
	proto.RegisterType((*CheckGitRequest)(nil), "gitserver.CheckGitRequest")
	proto.RegisterType((*CheckGitResponse)(nil), "gitserver.CheckGitResponse")
	proto.RegisterType((*RepoFilter)(nil), "gitserver.RepoFilter")
	proto.RegisterType((*UpdateRepoStatusRequest)(nil), "gitserver.UpdateRepoStatusRequest")
	proto.RegisterType((*GitCredentialsRequest)(nil), "gitserver.GitCredentialsRequest")
	proto.RegisterType((*GitCredentialsResponse)(nil), "gitserver.GitCredentialsResponse")
	proto.RegisterEnum("gitserver.REPOTAG", REPOTAG_name, REPOTAG_value)
	proto.RegisterEnum("gitserver.NewRepoState", NewRepoState_name, NewRepoState_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for GIT2 service

type GIT2Client interface {
	// check if there is a git server listening on that host
	CheckGitServer(ctx context.Context, in *CheckGitRequest, opts ...grpc.CallOption) (*CheckGitResponse, error)
	// get a repo by ID
	RepoByID(ctx context.Context, in *ByIDRequest, opts ...grpc.CallOption) (*SourceRepository, error)
	// get a repo by URL
	RepoByURL(ctx context.Context, in *ByURLRequest, opts ...grpc.CallOption) (*SourceRepository, error)
	// fork a repo, returns ID of new repo
	Fork(ctx context.Context, in *ForkRequest, opts ...grpc.CallOption) (*SourceRepository, error)
	// get all repos current user got access to. (Note: This is a global list, no longer "per gitserver"
	GetRepos(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*SourceRepositoryList, error)
	// create a new bare git repo
	CreateRepo(ctx context.Context, in *CreateRepoRequest, opts ...grpc.CallOption) (*SourceRepository, error)
	SetRepoFlags(ctx context.Context, in *SetRepoFlagsRequest, opts ...grpc.CallOption) (*common.Void, error)
	// mark this repository as complete. This is limited to repobuilder only
	RepoBuilderComplete(ctx context.Context, in *ByIDRequest, opts ...grpc.CallOption) (*common.Void, error)
	// reset this repository.  This is limited to repobuilder only and specific repositories. It serves to re-use test repositories. It resets the contents to
	// "bare" (but not the URL)
	ResetRepository(ctx context.Context, in *ByIDRequest, opts ...grpc.CallOption) (*common.Void, error)
	// delete a repository. it'll be gone thereafter
	DeleteRepository(ctx context.Context, in *ByIDRequest, opts ...grpc.CallOption) (*common.Void, error)
	// get repos with specific flags
	GetReposTags(ctx context.Context, in *RepoTagRequest, opts ...grpc.CallOption) (*SourceRepositoryList, error)
	// get recent builds
	GetRecentBuilds(ctx context.Context, in *ByIDRequest, opts ...grpc.CallOption) (*BuildList, error)
	// get most recent build
	GetLatestBuild(ctx context.Context, in *ByIDRequest, opts ...grpc.CallOption) (*Build, error)
	// make repobuilder no longer read-only
	UpdateRepoStatus(ctx context.Context, in *UpdateRepoStatusRequest, opts ...grpc.CallOption) (*SourceRepository, error)
}

type gIT2Client struct {
	cc *grpc.ClientConn
}

func NewGIT2Client(cc *grpc.ClientConn) GIT2Client {
	return &gIT2Client{cc}
}

func (c *gIT2Client) CheckGitServer(ctx context.Context, in *CheckGitRequest, opts ...grpc.CallOption) (*CheckGitResponse, error) {
	out := new(CheckGitResponse)
	err := grpc.Invoke(ctx, "/gitserver.GIT2/CheckGitServer", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gIT2Client) RepoByID(ctx context.Context, in *ByIDRequest, opts ...grpc.CallOption) (*SourceRepository, error) {
	out := new(SourceRepository)
	err := grpc.Invoke(ctx, "/gitserver.GIT2/RepoByID", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gIT2Client) RepoByURL(ctx context.Context, in *ByURLRequest, opts ...grpc.CallOption) (*SourceRepository, error) {
	out := new(SourceRepository)
	err := grpc.Invoke(ctx, "/gitserver.GIT2/RepoByURL", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gIT2Client) Fork(ctx context.Context, in *ForkRequest, opts ...grpc.CallOption) (*SourceRepository, error) {
	out := new(SourceRepository)
	err := grpc.Invoke(ctx, "/gitserver.GIT2/Fork", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gIT2Client) GetRepos(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*SourceRepositoryList, error) {
	out := new(SourceRepositoryList)
	err := grpc.Invoke(ctx, "/gitserver.GIT2/GetRepos", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gIT2Client) CreateRepo(ctx context.Context, in *CreateRepoRequest, opts ...grpc.CallOption) (*SourceRepository, error) {
	out := new(SourceRepository)
	err := grpc.Invoke(ctx, "/gitserver.GIT2/CreateRepo", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gIT2Client) SetRepoFlags(ctx context.Context, in *SetRepoFlagsRequest, opts ...grpc.CallOption) (*common.Void, error) {
	out := new(common.Void)
	err := grpc.Invoke(ctx, "/gitserver.GIT2/SetRepoFlags", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gIT2Client) RepoBuilderComplete(ctx context.Context, in *ByIDRequest, opts ...grpc.CallOption) (*common.Void, error) {
	out := new(common.Void)
	err := grpc.Invoke(ctx, "/gitserver.GIT2/RepoBuilderComplete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gIT2Client) ResetRepository(ctx context.Context, in *ByIDRequest, opts ...grpc.CallOption) (*common.Void, error) {
	out := new(common.Void)
	err := grpc.Invoke(ctx, "/gitserver.GIT2/ResetRepository", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gIT2Client) DeleteRepository(ctx context.Context, in *ByIDRequest, opts ...grpc.CallOption) (*common.Void, error) {
	out := new(common.Void)
	err := grpc.Invoke(ctx, "/gitserver.GIT2/DeleteRepository", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gIT2Client) GetReposTags(ctx context.Context, in *RepoTagRequest, opts ...grpc.CallOption) (*SourceRepositoryList, error) {
	out := new(SourceRepositoryList)
	err := grpc.Invoke(ctx, "/gitserver.GIT2/GetReposTags", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gIT2Client) GetRecentBuilds(ctx context.Context, in *ByIDRequest, opts ...grpc.CallOption) (*BuildList, error) {
	out := new(BuildList)
	err := grpc.Invoke(ctx, "/gitserver.GIT2/GetRecentBuilds", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gIT2Client) GetLatestBuild(ctx context.Context, in *ByIDRequest, opts ...grpc.CallOption) (*Build, error) {
	out := new(Build)
	err := grpc.Invoke(ctx, "/gitserver.GIT2/GetLatestBuild", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gIT2Client) UpdateRepoStatus(ctx context.Context, in *UpdateRepoStatusRequest, opts ...grpc.CallOption) (*SourceRepository, error) {
	out := new(SourceRepository)
	err := grpc.Invoke(ctx, "/gitserver.GIT2/UpdateRepoStatus", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for GIT2 service

type GIT2Server interface {
	// check if there is a git server listening on that host
	CheckGitServer(context.Context, *CheckGitRequest) (*CheckGitResponse, error)
	// get a repo by ID
	RepoByID(context.Context, *ByIDRequest) (*SourceRepository, error)
	// get a repo by URL
	RepoByURL(context.Context, *ByURLRequest) (*SourceRepository, error)
	// fork a repo, returns ID of new repo
	Fork(context.Context, *ForkRequest) (*SourceRepository, error)
	// get all repos current user got access to. (Note: This is a global list, no longer "per gitserver"
	GetRepos(context.Context, *common.Void) (*SourceRepositoryList, error)
	// create a new bare git repo
	CreateRepo(context.Context, *CreateRepoRequest) (*SourceRepository, error)
	SetRepoFlags(context.Context, *SetRepoFlagsRequest) (*common.Void, error)
	// mark this repository as complete. This is limited to repobuilder only
	RepoBuilderComplete(context.Context, *ByIDRequest) (*common.Void, error)
	// reset this repository.  This is limited to repobuilder only and specific repositories. It serves to re-use test repositories. It resets the contents to
	// "bare" (but not the URL)
	ResetRepository(context.Context, *ByIDRequest) (*common.Void, error)
	// delete a repository. it'll be gone thereafter
	DeleteRepository(context.Context, *ByIDRequest) (*common.Void, error)
	// get repos with specific flags
	GetReposTags(context.Context, *RepoTagRequest) (*SourceRepositoryList, error)
	// get recent builds
	GetRecentBuilds(context.Context, *ByIDRequest) (*BuildList, error)
	// get most recent build
	GetLatestBuild(context.Context, *ByIDRequest) (*Build, error)
	// make repobuilder no longer read-only
	UpdateRepoStatus(context.Context, *UpdateRepoStatusRequest) (*SourceRepository, error)
}

func RegisterGIT2Server(s *grpc.Server, srv GIT2Server) {
	s.RegisterService(&_GIT2_serviceDesc, srv)
}

func _GIT2_CheckGitServer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckGitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GIT2Server).CheckGitServer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gitserver.GIT2/CheckGitServer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GIT2Server).CheckGitServer(ctx, req.(*CheckGitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GIT2_RepoByID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ByIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GIT2Server).RepoByID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gitserver.GIT2/RepoByID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GIT2Server).RepoByID(ctx, req.(*ByIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GIT2_RepoByURL_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ByURLRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GIT2Server).RepoByURL(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gitserver.GIT2/RepoByURL",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GIT2Server).RepoByURL(ctx, req.(*ByURLRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GIT2_Fork_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ForkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GIT2Server).Fork(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gitserver.GIT2/Fork",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GIT2Server).Fork(ctx, req.(*ForkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GIT2_GetRepos_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GIT2Server).GetRepos(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gitserver.GIT2/GetRepos",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GIT2Server).GetRepos(ctx, req.(*common.Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _GIT2_CreateRepo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateRepoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GIT2Server).CreateRepo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gitserver.GIT2/CreateRepo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GIT2Server).CreateRepo(ctx, req.(*CreateRepoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GIT2_SetRepoFlags_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetRepoFlagsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GIT2Server).SetRepoFlags(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gitserver.GIT2/SetRepoFlags",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GIT2Server).SetRepoFlags(ctx, req.(*SetRepoFlagsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GIT2_RepoBuilderComplete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ByIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GIT2Server).RepoBuilderComplete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gitserver.GIT2/RepoBuilderComplete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GIT2Server).RepoBuilderComplete(ctx, req.(*ByIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GIT2_ResetRepository_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ByIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GIT2Server).ResetRepository(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gitserver.GIT2/ResetRepository",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GIT2Server).ResetRepository(ctx, req.(*ByIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GIT2_DeleteRepository_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ByIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GIT2Server).DeleteRepository(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gitserver.GIT2/DeleteRepository",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GIT2Server).DeleteRepository(ctx, req.(*ByIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GIT2_GetReposTags_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RepoTagRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GIT2Server).GetReposTags(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gitserver.GIT2/GetReposTags",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GIT2Server).GetReposTags(ctx, req.(*RepoTagRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GIT2_GetRecentBuilds_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ByIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GIT2Server).GetRecentBuilds(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gitserver.GIT2/GetRecentBuilds",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GIT2Server).GetRecentBuilds(ctx, req.(*ByIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GIT2_GetLatestBuild_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ByIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GIT2Server).GetLatestBuild(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gitserver.GIT2/GetLatestBuild",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GIT2Server).GetLatestBuild(ctx, req.(*ByIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GIT2_UpdateRepoStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateRepoStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GIT2Server).UpdateRepoStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gitserver.GIT2/UpdateRepoStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GIT2Server).UpdateRepoStatus(ctx, req.(*UpdateRepoStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _GIT2_serviceDesc = grpc.ServiceDesc{
	ServiceName: "gitserver.GIT2",
	HandlerType: (*GIT2Server)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CheckGitServer",
			Handler:    _GIT2_CheckGitServer_Handler,
		},
		{
			MethodName: "RepoByID",
			Handler:    _GIT2_RepoByID_Handler,
		},
		{
			MethodName: "RepoByURL",
			Handler:    _GIT2_RepoByURL_Handler,
		},
		{
			MethodName: "Fork",
			Handler:    _GIT2_Fork_Handler,
		},
		{
			MethodName: "GetRepos",
			Handler:    _GIT2_GetRepos_Handler,
		},
		{
			MethodName: "CreateRepo",
			Handler:    _GIT2_CreateRepo_Handler,
		},
		{
			MethodName: "SetRepoFlags",
			Handler:    _GIT2_SetRepoFlags_Handler,
		},
		{
			MethodName: "RepoBuilderComplete",
			Handler:    _GIT2_RepoBuilderComplete_Handler,
		},
		{
			MethodName: "ResetRepository",
			Handler:    _GIT2_ResetRepository_Handler,
		},
		{
			MethodName: "DeleteRepository",
			Handler:    _GIT2_DeleteRepository_Handler,
		},
		{
			MethodName: "GetReposTags",
			Handler:    _GIT2_GetReposTags_Handler,
		},
		{
			MethodName: "GetRecentBuilds",
			Handler:    _GIT2_GetRecentBuilds_Handler,
		},
		{
			MethodName: "GetLatestBuild",
			Handler:    _GIT2_GetLatestBuild_Handler,
		},
		{
			MethodName: "UpdateRepoStatus",
			Handler:    _GIT2_UpdateRepoStatus_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "protos/golang.conradwood.net/apis/gitserver/gitserver.proto",
}

// Client API for GITCredentials service

type GITCredentialsClient interface {
	// called by client if git calls it
	GitInvoked(ctx context.Context, in *GitCredentialsRequest, opts ...grpc.CallOption) (*GitCredentialsResponse, error)
}

type gITCredentialsClient struct {
	cc *grpc.ClientConn
}

func NewGITCredentialsClient(cc *grpc.ClientConn) GITCredentialsClient {
	return &gITCredentialsClient{cc}
}

func (c *gITCredentialsClient) GitInvoked(ctx context.Context, in *GitCredentialsRequest, opts ...grpc.CallOption) (*GitCredentialsResponse, error) {
	out := new(GitCredentialsResponse)
	err := grpc.Invoke(ctx, "/gitserver.GITCredentials/GitInvoked", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for GITCredentials service

type GITCredentialsServer interface {
	// called by client if git calls it
	GitInvoked(context.Context, *GitCredentialsRequest) (*GitCredentialsResponse, error)
}

func RegisterGITCredentialsServer(s *grpc.Server, srv GITCredentialsServer) {
	s.RegisterService(&_GITCredentials_serviceDesc, srv)
}

func _GITCredentials_GitInvoked_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GitCredentialsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GITCredentialsServer).GitInvoked(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/gitserver.GITCredentials/GitInvoked",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GITCredentialsServer).GitInvoked(ctx, req.(*GitCredentialsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _GITCredentials_serviceDesc = grpc.ServiceDesc{
	ServiceName: "gitserver.GITCredentials",
	HandlerType: (*GITCredentialsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GitInvoked",
			Handler:    _GITCredentials_GitInvoked_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "protos/golang.conradwood.net/apis/gitserver/gitserver.proto",
}

func init() {
	proto.RegisterFile("protos/golang.conradwood.net/apis/gitserver/gitserver.proto", fileDescriptor0)
}

var fileDescriptor0 = []byte{
	// 1831 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x9c, 0x58, 0x4f, 0x73, 0x1b, 0x49,
	0x15, 0x67, 0x24, 0xd9, 0x91, 0x9e, 0x25, 0x59, 0x69, 0x3b, 0xc9, 0xa0, 0x5d, 0x82, 0x99, 0x5a,
	0x52, 0xae, 0x00, 0x4e, 0xd0, 0xd6, 0x16, 0x2c, 0x81, 0xda, 0x92, 0xad, 0x3f, 0x11, 0xa5, 0xb5,
	0x45, 0x4b, 0x4e, 0x8e, 0x5b, 0xc3, 0x4c, 0x47, 0x9e, 0xb2, 0x34, 0x2d, 0xa6, 0x5b, 0xce, 0xfa,
	0x46, 0x15, 0x07, 0x0e, 0x5c, 0xe0, 0x04, 0x55, 0xdc, 0xb8, 0xef, 0x87, 0xe1, 0x33, 0xf0, 0x05,
	0xf8, 0x08, 0x54, 0xbf, 0x9e, 0xd1, 0xf4, 0x8c, 0x64, 0xc5, 0xe4, 0x62, 0xf7, 0x7b, 0xdd, 0xef,
	0xf5, 0x7b, 0xbf, 0x7e, 0xff, 0x34, 0xf0, 0x6a, 0x11, 0x71, 0xc9, 0xc5, 0x8b, 0x29, 0x9f, 0xb9,
	0xe1, 0xf4, 0xc4, 0xe3, 0x61, 0xe4, 0xfa, 0xef, 0x39, 0xf7, 0x4f, 0x42, 0x26, 0x5f, 0xb8, 0x8b,
	0x40, 0xbc, 0x98, 0x06, 0x52, 0xb0, 0xe8, 0x86, 0x45, 0xe9, 0xea, 0x04, 0xa5, 0x48, 0x65, 0xc5,
	0x68, 0x9e, 0x6c, 0x51, 0xe0, 0xf1, 0xf9, 0x9c, 0x87, 0xf1, 0x3f, 0x2d, 0xda, 0x7c, 0xbe, 0xe5,
	0xbc, 0xbb, 0x94, 0x57, 0xf8, 0x47, 0x9f, 0x75, 0xfe, 0x61, 0x41, 0xbd, 0x1f, 0xc8, 0xb3, 0x88,
	0xf9, 0x2c, 0x94, 0x81, 0x3b, 0x13, 0xa4, 0x0e, 0x85, 0x41, 0xc7, 0xb6, 0x8e, 0xac, 0xe3, 0x12,
	0x2d, 0x0c, 0x3a, 0xe4, 0x31, 0xec, 0x5e, 0x0a, 0x16, 0x0d, 0x3a, 0x76, 0xe1, 0xc8, 0x3a, 0xae,
	0xd0, 0x98, 0x22, 0x04, 0x4a, 0xaf, 0xb9, 0x90, 0x76, 0x11, 0xb9, 0xb8, 0x56, 0xbc, 0x91, 0x2b,
	0xaf, 0xec, 0x92, 0xe6, 0xa9, 0x35, 0x69, 0x42, 0x59, 0x49, 0x84, 0xee, 0x9c, 0xd9, 0x3b, 0xc8,
	0x5f, 0xd1, 0x6a, 0x6f, 0xe4, 0x0a, 0xf1, 0x9e, 0x47, 0xbe, 0xbd, 0xab, 0xf7, 0x12, 0xda, 0x71,
	0xa0, 0x4e, 0xd9, 0x82, 0x4f, 0xdc, 0x29, 0x65, 0x7f, 0x58, 0x32, 0x21, 0x49, 0x03, 0x8a, 0x13,
	0x77, 0x8a, 0xa6, 0xd5, 0xa8, 0x5a, 0x3a, 0xdf, 0x15, 0xa0, 0x76, 0x16, 0x31, 0x57, 0x32, 0x75,
	0x74, 0xc8, 0xa7, 0x6b, 0xd6, 0x3b, 0x50, 0x55, 0x5b, 0x22, 0x90, 0x3c, 0xba, 0x8d, 0x7d, 0x28,
	0xd1, 0x0c, 0xcf, 0xf0, 0xb0, 0x98, 0xf1, 0xd0, 0x86, 0x07, 0x67, 0x3c, 0x94, 0xec, 0x5b, 0x19,
	0x3b, 0x94, 0x90, 0x4a, 0xa2, 0xed, 0xc9, 0x80, 0x87, 0xe8, 0x51, 0x8d, 0xc6, 0x94, 0x92, 0x18,
	0x2f, 0x3d, 0x8f, 0x09, 0x81, 0xee, 0x94, 0x69, 0x42, 0x2a, 0x3b, 0xba, 0x51, 0xc4, 0xa3, 0xaf,
	0x99, 0x10, 0xee, 0x94, 0xd9, 0x0f, 0x50, 0x61, 0x86, 0x87, 0xd2, 0xd2, 0x8d, 0x24, 0xf3, 0xed,
	0x32, 0xaa, 0x4d, 0x48, 0x85, 0x53, 0x2f, 0x08, 0x03, 0x71, 0xc5, 0x7c, 0xbb, 0x82, 0x5b, 0x2b,
	0x9a, 0x3c, 0x87, 0x46, 0x5b, 0x08, 0xee, 0x05, 0xae, 0x32, 0x61, 0xc2, 0xaf, 0x59, 0x68, 0x03,
	0x6a, 0x5f, 0xe3, 0x3b, 0xff, 0xb1, 0x60, 0xe7, 0x74, 0x19, 0xcc, 0xfc, 0x8f, 0xc2, 0xe9, 0x29,
	0xc0, 0x19, 0x9f, 0xcf, 0x03, 0xf9, 0xda, 0x15, 0x57, 0x31, 0x56, 0x06, 0x47, 0xa1, 0x72, 0x1a,
	0xb9, 0xa1, 0x97, 0xbc, 0x7f, 0x4c, 0x29, 0xb9, 0x21, 0x9f, 0x26, 0x9e, 0xeb, 0x18, 0x30, 0x38,
	0x06, 0xfe, 0xbb, 0x19, 0xfc, 0x3f, 0x85, 0xca, 0x24, 0x98, 0x33, 0x21, 0xdd, 0xf9, 0x02, 0x01,
	0xab, 0xd1, 0x94, 0x61, 0x62, 0x5d, 0xce, 0x60, 0xed, 0x7c, 0x01, 0x15, 0x74, 0x72, 0x18, 0x08,
	0x49, 0x8e, 0x61, 0x17, 0x09, 0x61, 0x5b, 0x47, 0xc5, 0xe3, 0xbd, 0x56, 0xe3, 0x24, 0x4d, 0x35,
	0xdc, 0xa0, 0xf1, 0xbe, 0xf3, 0x1b, 0x1d, 0x70, 0xda, 0x5d, 0x94, 0xfd, 0x09, 0xec, 0x20, 0x27,
	0x16, 0x7d, 0x64, 0x88, 0xa6, 0x27, 0xa9, 0x3e, 0xe3, 0xf8, 0x00, 0x23, 0x16, 0xcd, 0x03, 0x21,
	0x54, 0x24, 0x10, 0x28, 0x51, 0xe6, 0xfa, 0x88, 0x70, 0x99, 0xe2, 0x9a, 0x1c, 0xc2, 0xce, 0xdb,
	0x28, 0x90, 0x0c, 0xc1, 0x2d, 0x53, 0x4d, 0x28, 0x3f, 0xba, 0xdf, 0x32, 0x6f, 0x29, 0x19, 0x42,
	0x5a, 0xa6, 0x09, 0xa9, 0x74, 0x28, 0x33, 0x10, 0xcd, 0x32, 0xc5, 0xb5, 0x73, 0x03, 0xe5, 0xb7,
	0xae, 0xf4, 0xae, 0x58, 0x74, 0xff, 0x4c, 0xcd, 0xbf, 0x6d, 0x71, 0xf3, 0xdb, 0x9e, 0x73, 0x19,
	0xbc, 0xbb, 0x95, 0xb7, 0x0b, 0x86, 0x37, 0xd6, 0xa8, 0xc1, 0x71, 0xbe, 0xb3, 0x00, 0x52, 0x81,
	0xb5, 0xab, 0x9b, 0x50, 0x56, 0xbb, 0xe7, 0x2a, 0xc9, 0xf5, 0xe5, 0x2b, 0x5a, 0x39, 0x78, 0xf1,
	0x3e, 0x34, 0xf2, 0x2b, 0x21, 0x95, 0x61, 0xed, 0x48, 0xb2, 0x77, 0xae, 0x27, 0x51, 0x52, 0x87,
	0x4d, 0x86, 0x47, 0xbe, 0x30, 0x61, 0xc5, 0xe0, 0xc9, 0x3e, 0x44, 0xba, 0x49, 0x8d, 0x83, 0xce,
	0x9f, 0x2c, 0x78, 0xd4, 0x8f, 0xf8, 0x72, 0x91, 0x1a, 0xdd, 0xd6, 0x99, 0xb8, 0x01, 0x35, 0x75,
	0x66, 0x15, 0xf3, 0x31, 0xa5, 0xcc, 0x46, 0x05, 0xa9, 0xd9, 0x31, 0xb9, 0x7a, 0xdb, 0xd2, 0xa6,
	0xb7, 0xdd, 0x31, 0xde, 0xd6, 0xf9, 0xa3, 0x05, 0x87, 0xea, 0x11, 0x3e, 0xda, 0x88, 0xbb, 0x4a,
	0xd3, 0xfd, 0x4d, 0xf8, 0xab, 0x05, 0x64, 0xc4, 0x85, 0xa4, 0xcc, 0x63, 0xc1, 0x0d, 0x4b, 0x6a,
	0xe9, 0x67, 0x50, 0x53, 0x57, 0x74, 0x82, 0x88, 0x79, 0xca, 0x2e, 0xb4, 0xa5, 0x42, 0xb3, 0x4c,
	0x55, 0x71, 0x29, 0x7b, 0x17, 0xbf, 0xa8, 0x5a, 0x92, 0x23, 0xd8, 0xbb, 0x98, 0xf9, 0x94, 0xdd,
	0x04, 0xf8, 0x1e, 0xda, 0x2a, 0x93, 0xa5, 0x4e, 0x9c, 0xb3, 0xf7, 0xab, 0x13, 0xfa, 0x4d, 0x4d,
	0x96, 0x73, 0x00, 0x0f, 0x0d, 0x8b, 0xc6, 0x32, 0x62, 0xee, 0xdc, 0xf9, 0x01, 0xec, 0x9d, 0xde,
	0x0e, 0x3a, 0x89, 0x7d, 0x39, 0x80, 0x9c, 0x23, 0xa8, 0x9e, 0xde, 0x5e, 0xd2, 0xa1, 0xd1, 0x0b,
	0x2e, 0xe9, 0x30, 0xb6, 0x5a, 0x2d, 0x9d, 0xbe, 0x99, 0xbe, 0x83, 0xf0, 0x1d, 0x57, 0xa1, 0x93,
	0x72, 0xf0, 0xe8, 0x9d, 0x39, 0x6c, 0x1c, 0x74, 0xfe, 0x66, 0xc1, 0x83, 0x7e, 0x20, 0x51, 0x45,
	0x3e, 0x75, 0xac, 0xad, 0xed, 0x23, 0x9b, 0x76, 0x4f, 0xa1, 0xa4, 0x56, 0x88, 0xd1, 0x5e, 0x0b,
	0x4e, 0xb0, 0xed, 0x62, 0x34, 0x20, 0x5f, 0x05, 0xd8, 0x1b, 0x16, 0xad, 0x40, 0xaa, 0xd1, 0x84,
	0x4c, 0x9c, 0xdb, 0x49, 0x9d, 0xfb, 0x8b, 0x05, 0x0f, 0xd3, 0x46, 0x97, 0x80, 0x90, 0xcf, 0x1f,
	0x6b, 0x43, 0xfe, 0xbc, 0xd4, 0xba, 0x0a, 0x68, 0xc4, 0x53, 0xc3, 0xfb, 0x31, 0x5f, 0x46, 0x1e,
	0x4b, 0x3d, 0x51, 0xe0, 0xaa, 0xa3, 0xea, 0x01, 0x3b, 0x4c, 0x78, 0x51, 0xb0, 0x90, 0xc6, 0x13,
	0x1b, 0x2c, 0xe7, 0xbf, 0x3b, 0xd0, 0xc8, 0x8b, 0x6f, 0x2a, 0x09, 0xbd, 0x60, 0xc6, 0x70, 0x1e,
	0x88, 0x4b, 0x42, 0x42, 0x93, 0x16, 0x94, 0x2e, 0xe9, 0x50, 0xd8, 0x45, 0xac, 0xab, 0x1f, 0xb2,
	0x0a, 0xcf, 0xde, 0xab, 0x58, 0x3c, 0x83, 0x3a, 0x5d, 0x86, 0x46, 0x70, 0xc5, 0xb9, 0x90, 0xe3,
	0x62, 0xf4, 0x2f, 0xc3, 0x51, 0xc4, 0x92, 0x63, 0xba, 0x5b, 0x67, 0x99, 0xe4, 0x18, 0xf6, 0x35,
	0xe6, 0xfe, 0x19, 0x9f, 0x2f, 0x66, 0x4c, 0xea, 0xb6, 0x5d, 0xa6, 0x79, 0x76, 0x1e, 0xb2, 0xf2,
	0x1a, 0x64, 0xea, 0x84, 0x7a, 0x74, 0xdd, 0x2d, 0x05, 0x36, 0xf1, 0x12, 0x35, 0x59, 0x2a, 0x1c,
	0x3a, 0x4c, 0x69, 0xf3, 0xb1, 0x7d, 0x97, 0x69, 0x42, 0xaa, 0x0e, 0x1f, 0x2f, 0xd3, 0x76, 0xb8,
	0x87, 0x11, 0xb3, 0xc6, 0x57, 0x75, 0x5c, 0xf3, 0x30, 0xf4, 0xaa, 0xba, 0xd7, 0xa6, 0x1c, 0xec,
	0xc5, 0xae, 0x90, 0xfa, 0x52, 0xbb, 0xa6, 0xeb, 0x7c, 0xca, 0x51, 0x08, 0xa6, 0x14, 0xea, 0xa8,
	0xa3, 0x8e, 0x1c, 0x57, 0x15, 0xa0, 0x89, 0x3b, 0x15, 0xf6, 0x3e, 0x6a, 0xc0, 0xb5, 0xf2, 0xa0,
	0xc7, 0xa3, 0xeb, 0x20, 0x9c, 0xda, 0x0d, 0xed, 0x41, 0x4c, 0xaa, 0x5b, 0xd5, 0x92, 0xf9, 0xbd,
	0x88, 0xcf, 0xed, 0x87, 0xe8, 0xbc, 0xc1, 0x21, 0x2f, 0xe1, 0x40, 0xf7, 0x62, 0xbe, 0x94, 0x41,
	0x38, 0x9d, 0xb8, 0x53, 0x7c, 0x62, 0x82, 0x57, 0x6f, 0xda, 0x22, 0x2d, 0x38, 0xcc, 0xb1, 0xdf,
	0xb8, 0xb3, 0x25, 0xb3, 0x0f, 0x50, 0x64, 0xe3, 0x9e, 0x6e, 0x52, 0xae, 0x7f, 0x11, 0xce, 0x6e,
	0xed, 0x43, 0x34, 0x70, 0x45, 0xe3, 0x6c, 0x83, 0x8f, 0x8a, 0x3e, 0x3f, 0x8a, 0x67, 0x9b, 0x15,
	0xc7, 0x59, 0xc2, 0xc1, 0x86, 0xd0, 0x5c, 0x0b, 0xfa, 0x67, 0x50, 0x7f, 0xd3, 0xda, 0x30, 0x48,
	0xe5, 0xb8, 0xf7, 0x1d, 0x9e, 0x9d, 0x01, 0x1c, 0xe6, 0xaf, 0xc5, 0xc9, 0xe4, 0xe7, 0xd9, 0xc9,
	0xe4, 0x93, 0x2d, 0x19, 0x94, 0xcc, 0x27, 0x7f, 0xb7, 0xe0, 0x60, 0xcc, 0xa4, 0x22, 0x7a, 0x33,
	0x77, 0x2a, 0x92, 0x22, 0x92, 0xb6, 0x1e, 0x2b, 0xd3, 0x7a, 0xd6, 0x73, 0xa9, 0x70, 0xbf, 0x5c,
	0x2a, 0x6e, 0xca, 0x25, 0x13, 0xfb, 0x52, 0x16, 0x7b, 0xe7, 0xdf, 0x16, 0xec, 0xa9, 0x60, 0x30,
	0xca, 0xda, 0x07, 0x8b, 0x6e, 0xbe, 0x1a, 0x14, 0xee, 0x2e, 0x7d, 0xc5, 0x8f, 0x2e, 0x7d, 0xa5,
	0xf5, 0x3c, 0x7e, 0x06, 0xf5, 0xa4, 0x0e, 0xc7, 0xde, 0xc4, 0x15, 0x26, 0xcb, 0x75, 0xfe, 0x6c,
	0x41, 0x65, 0x14, 0x84, 0xd3, 0xb1, 0x74, 0x25, 0x5b, 0x0b, 0x93, 0x4d, 0x33, 0x7b, 0x61, 0xf3,
	0xcc, 0x8e, 0xbf, 0x42, 0x74, 0xb9, 0x41, 0x4f, 0x6a, 0x34, 0x21, 0x75, 0x0f, 0x17, 0x0b, 0x1e,
	0x0a, 0xa6, 0x55, 0x94, 0x92, 0x1e, 0x6e, 0x30, 0x9d, 0x1f, 0xc3, 0xfe, 0xd9, 0x15, 0xf3, 0xae,
	0xfb, 0x81, 0x4c, 0x00, 0x4e, 0xa2, 0xcf, 0x4a, 0xa3, 0xcf, 0xf9, 0x29, 0x34, 0xd2, 0x63, 0x5a,
	0xde, 0x1c, 0xb1, 0xad, 0xec, 0x88, 0xfd, 0x4a, 0xb7, 0xd6, 0x5e, 0x30, 0x93, 0x2c, 0x22, 0x3f,
	0x8b, 0x8b, 0x81, 0x6e, 0xb1, 0xdf, 0xcf, 0xb5, 0xd8, 0xf4, 0x17, 0x9c, 0xae, 0x13, 0xce, 0x3f,
	0x2d, 0x78, 0x72, 0xb9, 0xf0, 0xe3, 0x66, 0xa6, 0x10, 0x5a, 0x7e, 0x30, 0x1a, 0x3f, 0x37, 0xe2,
	0x47, 0x21, 0x55, 0x6f, 0x3d, 0x31, 0xae, 0xc1, 0xe9, 0x42, 0xab, 0x62, 0x46, 0x52, 0x2b, 0xa1,
	0x65, 0xf8, 0x9a, 0xf3, 0x6b, 0x81, 0xd8, 0x6d, 0x15, 0x8a, 0x0f, 0x3a, 0x1e, 0x3c, 0xca, 0xfe,
	0x22, 0x36, 0x50, 0x6b, 0x47, 0x53, 0x9d, 0x72, 0x15, 0x8a, 0x6b, 0x15, 0x30, 0xdd, 0xf0, 0x26,
	0x88, 0x78, 0x38, 0x67, 0xa1, 0xb4, 0x0b, 0xb8, 0x65, 0xb2, 0xd4, 0x54, 0x36, 0x96, 0x7e, 0x90,
	0xf4, 0x51, 0x4d, 0x38, 0x2f, 0xe1, 0x71, 0xfe, 0x92, 0x18, 0xf3, 0xc7, 0xb0, 0x3b, 0x96, 0x3e,
	0x5f, 0x26, 0xaf, 0x13, 0x53, 0xcf, 0x3b, 0xf0, 0x80, 0x76, 0x47, 0x17, 0x93, 0x76, 0x9f, 0xd4,
	0xa0, 0x72, 0x79, 0xde, 0xe9, 0xf6, 0x06, 0xe7, 0xdd, 0x4e, 0xe3, 0x7b, 0xa4, 0x0a, 0xe5, 0xde,
	0x80, 0x7e, 0xfd, 0xb6, 0x4d, 0xbb, 0x0d, 0x8b, 0x00, 0xec, 0x0e, 0x2f, 0xda, 0x9d, 0x2e, 0x6d,
	0x14, 0x48, 0x03, 0xaa, 0xc9, 0xce, 0x37, 0xed, 0xd1, 0xa8, 0x51, 0x7c, 0xfe, 0x25, 0x54, 0x4d,
	0xb7, 0x95, 0xec, 0xf9, 0xc5, 0xd9, 0xeb, 0xf6, 0x79, 0xbf, 0xab, 0x35, 0x8d, 0xbb, 0x93, 0x6f,
	0x26, 0xf4, 0x52, 0x69, 0xaa, 0x41, 0x45, 0x51, 0xbd, 0xf6, 0x70, 0xdc, 0x6d, 0x14, 0x5a, 0xff,
	0x7a, 0x00, 0xa5, 0xfe, 0x60, 0xd2, 0x22, 0x03, 0xa8, 0x27, 0x91, 0x32, 0x46, 0x24, 0x49, 0xd3,
	0x40, 0x35, 0x17, 0x6b, 0xcd, 0x4f, 0x36, 0xee, 0xc5, 0xce, 0x7e, 0xa5, 0x7f, 0x36, 0x9c, 0xe2,
	0x18, 0x65, 0xfe, 0x30, 0x4b, 0x27, 0xc1, 0xe6, 0xb6, 0xda, 0x46, 0xda, 0x50, 0xd1, 0x0a, 0x54,
	0xf6, 0x3e, 0xc9, 0x68, 0x48, 0x87, 0xc5, 0xed, 0x2a, 0x5e, 0x41, 0x49, 0x15, 0x9f, 0xcc, 0xfd,
	0x46, 0x35, 0xda, 0x2e, 0xfc, 0x25, 0x94, 0xfb, 0xba, 0xa6, 0x0a, 0x52, 0x3d, 0x89, 0x3f, 0xc3,
	0xbc, 0xe1, 0x81, 0xdf, 0xfc, 0xe1, 0x16, 0x31, 0x2c, 0xe1, 0xfd, 0xa4, 0xe3, 0x28, 0x3e, 0xf9,
	0xd4, 0x84, 0x29, 0x3f, 0xe8, 0x6d, 0xb7, 0xe1, 0xd7, 0x50, 0x35, 0xeb, 0x3a, 0xc9, 0x54, 0xba,
	0xf5, 0x82, 0xdf, 0xcc, 0xd8, 0x49, 0x5e, 0xc1, 0x01, 0x22, 0xa8, 0x1a, 0x26, 0x0e, 0x23, 0x7a,
	0xa2, 0xb9, 0xeb, 0x35, 0xb2, 0xc2, 0xbf, 0x80, 0x7d, 0xca, 0x44, 0x0c, 0x80, 0xb6, 0xe6, 0x7e,
	0x82, 0xbf, 0x4c, 0x46, 0x9a, 0xff, 0x5b, 0xf2, 0xb7, 0x50, 0x4d, 0x10, 0xc7, 0xa1, 0xe3, 0xee,
	0x6a, 0xf3, 0xe1, 0x27, 0xf8, 0x0a, 0xf6, 0x51, 0x97, 0xc7, 0x42, 0xa9, 0x3f, 0x02, 0xdc, 0x69,
	0xc4, 0x61, 0xfe, 0xb3, 0x01, 0x2a, 0xf8, 0x15, 0xd4, 0xfb, 0x4c, 0x0e, 0x5d, 0xc9, 0x84, 0x56,
	0x70, 0xa7, 0xfc, 0xda, 0x67, 0x07, 0x32, 0x86, 0x46, 0xbe, 0x08, 0x12, 0xc7, 0x38, 0x75, 0x47,
	0x85, 0xdc, 0x1a, 0x0b, 0x2d, 0x0f, 0xea, 0xfd, 0xc1, 0xc4, 0xfc, 0x9c, 0xf7, 0x3b, 0x00, 0xfc,
	0x31, 0x73, 0xc3, 0xaf, 0x99, 0x4f, 0x8e, 0x0c, 0xe1, 0x8d, 0x55, 0xae, 0xf9, 0xa3, 0x2d, 0x27,
	0x74, 0xd6, 0x9e, 0x3e, 0x83, 0xcf, 0x42, 0x26, 0xcd, 0xef, 0x8b, 0xf1, 0x17, 0x47, 0x77, 0x11,
	0x88, 0x54, 0xfc, 0xf7, 0xbb, 0xf8, 0x8d, 0xf1, 0xf3, 0xff, 0x05, 0x00, 0x00, 0xff, 0xff, 0x41,
	0x64, 0x95, 0xd9, 0x09, 0x15, 0x00, 0x00,
}
